diff -u -r -w nmap-2.54BETA36/global_structures.h nmap-2.54BETA36_ipv6/global_structures.h
--- nmap-2.54BETA36/global_structures.h	Sun Apr 21 11:57:27 2002
+++ nmap-2.54BETA36_ipv6/global_structures.h	Sun Jun 16 21:58:52 2002
@@ -177,10 +177,20 @@
 		the fields are not valid */
 };
 
+struct targets6 {               /*IPv6*/
+  u32 netmask;
+  unsigned int maskformat;
+  struct in6_addr start;
+  struct in6_addr currentaddr;
+  struct in6_addr end;    
+  int nleft;
+};
 
 struct hoststruct {
   struct in_addr host;
+  struct in6_addr host6;             
   struct in_addr source_ip;
+  struct in6_addr source_ipv6;        
   char *name;
   struct seq_info seq;
   struct FingerPrintResults FPR;
@@ -224,14 +234,17 @@
   int next_expression;   /* The index of the next expression we have
 			    to handle */
   struct targets current_expression; /* For batch chunking */
+  struct targets6 current_expression6;                       
 };
 
 struct ops /* someone took struct options, <grrr> */ {
+  int af;   /*  AF address family:  AF_INET or AF_INET6 */   
   int debugging;
   int verbose;
   int randomize_hosts;
   int spoofsource; /* -S used */
   struct in_addr *source;
+  struct in6_addr *source6;
   char device[64];
   int interactivemode;
   int host_group_sz;
@@ -261,6 +274,7 @@
 			       to 0. */
   int isr00t;
   struct in_addr decoys[MAX_DECOYS];
+  struct in6_addr decoys6[MAX_DECOYS];              /*IPv6*/
   int osscan_limit; /* Skip OS Scan if no open or no closed TCP ports */
   int osscan_guess;   /* Be more aggressive in guessing OS type */
   int numdecoys;
Only in nmap-2.54BETA36_ipv6/: ipv6_change
diff -u -r -w nmap-2.54BETA36/nmap.c nmap-2.54BETA36_ipv6/nmap.c
--- nmap-2.54BETA36/nmap.c	Thu Jun 13 01:57:42 2002
+++ nmap-2.54BETA36_ipv6/nmap.c	Tue Jun 18 17:22:03 2002
@@ -165,6 +165,13 @@
   time_t timep;
   char mytime[128];
   int option_index;
+
+  char addr_buf[INET6_ADDRSTRLEN], hostname[256], *host;    
+  struct sockaddr_in tmp_sin;                               
+  struct sockaddr_in6 tmp_sin6;                             
+  int  fail;                                                
+  struct addrinfo hints, *result, tmp_addrinfo;             
+
   struct option long_options[] =
   {
     {"version", no_argument, 0, 'V'},
@@ -228,6 +235,8 @@
   }
 #endif
 
+  o.af = AF_INET;    /* Default IP version setting is IPv4. */ 
+
   /* argv faking silliness */
   fakeargv = (char **) safe_malloc(sizeof(char *) * (argc + 1));
   for(i=0; i < argc; i++) {
@@ -241,7 +250,7 @@
 
   /* OK, lets parse these args! */
   optind = 1; /* so it can be called multiple times */
-  while((arg = getopt_long_only(argc,fakeargv,"b:D:d::e:Ffg:hIi:M:m:NnOo:P:p:qRrS:s:T:Vv", long_options, &option_index)) != EOF) {
+  while((arg = getopt_long_only(argc,fakeargv,"b:D:d::e:Ffg:hIi:M:m:NnOo:P:p:qRrS:s:T:Vv:6", long_options, &option_index)) != EOF) {
     switch(arg) {
     case 0:
       if (strcmp(long_options[option_index].name, "max_rtt_timeout") == 0) {
@@ -566,6 +575,8 @@
       exit(0);
       break;
     case 'v': o.verbose++; break;
+    case '6':                              /*IPv6*/
+      o.af = AF_INET6;                      
     }
   }
 
@@ -782,6 +793,13 @@
     error("WARNING:  -g is incompatible with the default connect() scan (-sT).  Use a raw scan such as -sS if you want to set the source port.");
   }
 
+
+  if(o.af == AF_INET6){                    /*IPv6*/
+    if((o.connectscan + o.udpscan + o.windowscan +o.synscan
+	+ o.finscan + o.xmasscan + o.ackscan + o.nullscan + o.ipprotscan) == 0) 
+      fatal(" The IPv6 scan features are actually only available for the following scans:\n -sT,-sS,-sA,-sW,-sF,-sX,-sN,-sU\n");
+  } 
+  
   /* Set up our array of decoys! */
   if (o.decoyturn == -1) {
     o.decoyturn = (o.numdecoys == 0)?  0 : get_random_uint() % o.numdecoys; 
@@ -930,18 +948,36 @@
 	currenths->host_timeout.tv_usec %= 1000000;
       }
       
-      /*    printf("Nexthost() returned: %s\n", inet_ntoa(currenths->host));*/
-      target = NULL;
+      if(o.af == AF_INET6){      /*IPv6*/
+	tmp_sin6.sin6_family = AF_INET6;
+	memcpy(&(tmp_sin6.sin6_addr),  &(currenths->host6), sizeof(struct in6_addr));
+	tmp_addrinfo.ai_family = AF_INET6;
+	tmp_addrinfo.ai_addr = (struct sockaddr *)&tmp_sin6;
+	tmp_addrinfo.ai_addrlen = sizeof(struct sockaddr_in6);	
+	/*printf("Nexthost() returned: %s\n", inet_ntop(o.af, &(currenths->host6), addr_buf, sizeof(addr_buf)));*/
+      }
+      else{    /* IPv4 */
+	tmp_sin.sin_family = AF_INET;
+	memcpy(&(tmp_sin.sin_addr),  &(currenths->host), sizeof(struct in_addr));
+	tmp_addrinfo.ai_family = AF_INET;
+	tmp_addrinfo.ai_addr = (struct sockaddr *)&tmp_sin;
+	tmp_addrinfo.ai_addrlen = sizeof(struct sockaddr_in);		
+	/*printf("Nexthost() returned: %s\n\n", inet_ntop(o.af, &(currenths->host), addr_buf, sizeof(addr_buf)));*/
+      }
+     
       if (((currenths->flags & HOST_UP) || resolve_all) && !o.noresolve)
-	target = gethostbyaddr((char *) &currenths->host, 4, AF_INET);
-      if (target && *target->h_name) {
-	currenths->name = strdup(target->h_name);
+	fail = getnameinfo((struct sockaddr *) tmp_addrinfo.ai_addr, tmp_addrinfo.ai_addrlen, hostname, sizeof(hostname), NULL, 0,0);
+
+    
+      if(!fail && hostname){
+	currenths->name = strdup(hostname);
       }
       else {
 	currenths->name = emptystring;
       }
       
       if (o.source) memcpy(&currenths->source_ip, o.source, sizeof(struct in_addr));
+      if (o.source6) memcpy(&currenths->source_ipv6, o.source6, sizeof(struct in6_addr));     
       log_write(LOG_XML, "<host>");
       write_host_status(currenths, resolve_all);
       
@@ -954,13 +990,25 @@
       if (currenths->flags & HOST_UP /*&& !currenths->wierd_responses*/ &&
 	  !o.pingscan && !o.listscan) {
 	
-	if (currenths->flags & HOST_UP && !currenths->source_ip.s_addr && ( o.windowscan || o.synscan || o.idlescan || o.finscan || o.maimonscan || o.udpscan || o.nullscan || o.xmasscan || o.ackscan || o.ipprotscan )) {
+	if (currenths->flags & HOST_UP && (!currenths->source_ip.s_addr && !currenths->source_ipv6.s6_addr) && ( o.windowscan || o.synscan || o.idlescan || o.finscan || o.maimonscan || o.udpscan || o.nullscan || o.xmasscan || o.ackscan || o.ipprotscan )) {
+	  hints.ai_family = o.af; 
 	  if (gethostname(myname, MAXHOSTNAMELEN) || 
-	      !(target = gethostbyname(myname)))
+	      (getaddrinfo(myname, NULL, &hints, &result)))
 	    fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n"); 
-	  memcpy(&currenths->source_ip, target->h_addr_list[0], sizeof(struct in_addr));
+	  
+	  if(o.af == AF_INET6){        /*IPv6*/
+	    memcpy(&currenths->source_ipv6, &((struct sockaddr_in6 *)result->ai_addr)->sin6_addr, sizeof(struct in6_addr));  
+	    host =(char *) &(currenths->source_ipv6);
+	  }
+	  else{                        /*IPv4*/
+	    memcpy(&currenths->source_ip, &((struct sockaddr_in *)result->ai_addr)->sin_addr, sizeof(struct in_addr));
+	    host =(char *) &(currenths->source_ip);
+	  }
+	  
+	  freeaddrinfo(result);     
+	  
 	  if (! sourceaddrwarning) {
-	    fprintf(stderr, "WARNING:  We could not determine for sure which interface to use, so we are guessing %s .  If this is wrong, use -S <my_IP_address>.\n", inet_ntoa(currenths->source_ip));
+	    fprintf(stderr, "WARNING:  We could not determine for sure which interface to use, so we are guessing %s .  If this is wrong, use -S <my_IP_address>.\n", inet_ntop(o.af, host, addr_buf, sizeof(addr_buf)));
 	    sourceaddrwarning = 1;
 	  }
 	}
@@ -969,8 +1017,10 @@
 	if (!*currenths->device && currenths->flags & HOST_UP && (o.nullscan || o.xmasscan || o.ackscan || o.udpscan || o.idlescan || o.finscan || o.maimonscan ||  o.synscan || o.osscan || o.windowscan || o.ipprotscan) && (ipaddr2devname( currenths->device, &currenths->source_ip) != 0))
 	  fatal("Could not figure out what device to send the packet out on!  You might possibly want to try -S (but this is probably a bigger problem).  If you are trying to sp00f the source of a SYN/FIN scan with -S <fakeip>, then you must use -e eth0 (or other devicename) to tell us what interface to use.\n");
 	/* Set up the decoy */
+	if(o.af == AF_INET6)
+	  o.decoys6[o.decoyturn] = currenths->source_ipv6;
+	else
 	o.decoys[o.decoyturn] = currenths->source_ip;
-	
 	/* Time for some actual scanning! */    
 	        /* Time for some actual scanning! */    
 	if (o.synscan) pos_scan(currenths, ports->tcp_ports, ports->tcp_count, SYN_SCAN);
@@ -1177,6 +1227,8 @@
   int res;
   static int bind_failed=0;
   struct sockaddr_in sin;
+  struct sockaddr_in6 sin6;
+  char buf[INET6_ADDRSTRLEN]; 
 
   l.l_onoff = 1;
   l.l_linger = 0;
@@ -1186,7 +1238,20 @@
       fprintf(stderr, "Problem setting socket SO_LINGER, errno: %d\n", errno);
       perror("setsockopt");
     }
-  if (o.spoofsource && !bind_failed)
+  if(o.spoofsource && !bind_failed && (o.af == AF_INET6))        /*IPv6*/
+  {
+      bzero(&sin6,sizeof(sin6));
+      sin6.sin6_family=AF_INET6;
+      memcpy(&sin6.sin6_addr,o.source,sizeof(sin6.sin6_addr));
+      res=bind(sd,(struct sockaddr*)&sin6,sizeof(sin6));
+      if (res<0)
+	{
+	  fprintf(stderr, "init_socket: Problem binding source address (%s), errno :%d\n", inet_ntop(AF_INET6, &(sin6.sin6_addr), buf, sizeof(buf)), errno);
+	  perror("bind");
+	  bind_failed=1;
+	}
+  }
+  else if (o.spoofsource && !bind_failed && (o.af == AF_INET))   /*IPv4*/
     {
       bzero(&sin,sizeof(sin));
       sin.sin_family=AF_INET;
diff -u -r -w nmap-2.54BETA36/osscan.c nmap-2.54BETA36_ipv6/osscan.c
--- nmap-2.54BETA36/osscan.c	Thu Jun 13 01:58:08 2002
+++ nmap-2.54BETA36_ipv6/osscan.c	Sun Jun 16 19:49:38 2002
@@ -204,28 +204,28 @@
      /* Test 1 */
      if (!FPtests[1]) {     
        if (o.scan_delay) enforce_scan_delay(NULL);
-       send_tcp_raw_decoys(rawsd, &target->host, current_port, 
+       send_tcp_raw_decoys(rawsd, target, current_port, 
 			   openport, sequence_base, 0,TH_BOGUS|TH_SYN, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
      }
      
      /* Test 2 */
      if (!FPtests[2]) {     
        if (o.scan_delay) enforce_scan_delay(NULL);
-       send_tcp_raw_decoys(rawsd, &target->host, current_port +1, 
+       send_tcp_raw_decoys(rawsd, target, current_port +1, 
 			   openport, sequence_base, 0,0, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
      }
 
      /* Test 3 */
      if (!FPtests[3]) {     
        if (o.scan_delay) enforce_scan_delay(NULL);
-       send_tcp_raw_decoys(rawsd, &target->host, current_port +2, 
+       send_tcp_raw_decoys(rawsd, target, current_port +2, 
 			   openport, sequence_base, 0,TH_SYN|TH_FIN|TH_URG|TH_PUSH, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
      }
 
      /* Test 4 */
      if (!FPtests[4]) {     
        if (o.scan_delay) enforce_scan_delay(NULL);
-       send_tcp_raw_decoys(rawsd, &target->host, current_port +3, 
+       send_tcp_raw_decoys(rawsd, target, current_port +3, 
 			   openport, sequence_base, 0,TH_ACK, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
      }
    }
@@ -233,21 +233,21 @@
    /* Test 5 */
    if (!FPtests[5]) {   
      if (o.scan_delay) enforce_scan_delay(NULL);
-     send_tcp_raw_decoys(rawsd, &target->host, current_port +4,
+     send_tcp_raw_decoys(rawsd, target, current_port +4,
 			 closedport, sequence_base, 0,TH_SYN, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
    }
 
      /* Test 6 */
    if (!FPtests[6]) {   
      if (o.scan_delay) enforce_scan_delay(NULL);
-     send_tcp_raw_decoys(rawsd, &target->host, current_port +5, 
+     send_tcp_raw_decoys(rawsd, target, current_port +5, 
 			 closedport, sequence_base, 0,TH_ACK, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
    }
 
      /* Test 7 */
    if (!FPtests[7]) {
      if (o.scan_delay) enforce_scan_delay(NULL);   
-     send_tcp_raw_decoys(rawsd, &target->host, current_port +6, 
+     send_tcp_raw_decoys(rawsd, target, current_port +6, 
 			 closedport, sequence_base, 0,TH_FIN|TH_PUSH|TH_URG, 0,"\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000" , 20, NULL, 0);
    }
 
@@ -329,7 +329,7 @@
    seq_packets_sent = 0;
    while (seq_packets_sent < NUM_SEQ_SAMPLES) {
      if (o.scan_delay) enforce_scan_delay(NULL);
-     send_tcp_raw_decoys(rawsd, &target->host, 
+     send_tcp_raw_decoys(rawsd, target, 
 			 o.magic_port + seq_packets_sent + 1, 
 			 openport, 
 			 sequence_base + seq_packets_sent + 1, 0, 
diff -u -r -w nmap-2.54BETA36/output.c nmap-2.54BETA36_ipv6/output.c
--- nmap-2.54BETA36/output.c	Tue Apr 30 07:53:46 2002
+++ nmap-2.54BETA36_ipv6/output.c	Tue Jun 11 16:50:25 2002
@@ -74,6 +74,12 @@
   int numignoredports;
   int portno, protocount;
   struct port **protoarrays[2];
+  char buf_adr[INET6_ADDRSTRLEN];                                /*IPv6*/
+  char *host;                                     
+  if(o.af == AF_INET6)
+    host = (char *) &(currenths->host6);
+  else
+    host = (char *) &(currenths->host);           
 
   numignoredports = plist->state_counts[plist->ignored_port_state];
 
@@ -89,18 +95,18 @@
               "%s %d scanned %s on %s (%s) %s: %s\n",
 	      (numignoredports == 1)? "The" : "All", numignoredports,
 	      (numignoredports == 1)? "port" : "ports", currenths->name, 
-	      inet_ntoa(currenths->host), 
+	      inet_ntop(o.af, host, buf_adr, sizeof(buf_adr)),    
 	      (numignoredports == 1)? "is" : "are", 
 	      statenum2str(currenths->ports.ignored_port_state));
     log_write(LOG_MACHINE,"Host: %s (%s)\tStatus: Up", 
-	      inet_ntoa(currenths->host), currenths->name);
+	      inet_ntop(o.af, host, buf_adr, sizeof(buf_adr)), currenths->name); 
     log_write(LOG_XML, "</ports>\n");
     return;
   }
 
   log_write(LOG_NORMAL|LOG_SKID|LOG_STDOUT,"Interesting %s on %s (%s):\n",
 	    (o.ipprotscan)? "protocols" : "ports", currenths->name, 
-	    inet_ntoa(currenths->host));
+	    inet_ntop(o.af, host, buf_adr, sizeof(buf_adr)));  
   log_write(LOG_MACHINE,"Host: %s (%s)", inet_ntoa(currenths->host), 
 	    currenths->name);
   
diff -u -r -w nmap-2.54BETA36/scan_engine.c nmap-2.54BETA36_ipv6/scan_engine.c
--- nmap-2.54BETA36/scan_engine.c	Thu Jun 13 20:25:58 2002
+++ nmap-2.54BETA36_ipv6/scan_engine.c	Wed Jun 19 21:34:48 2002
@@ -204,8 +204,12 @@
   int res;
 #ifdef LINUX
   struct sockaddr_in sin,sout;
+  struct sockaddr_in6 sin6,sout6; 
   NET_SIZE_T sinlen = sizeof(sin);
   NET_SIZE_T soutlen = sizeof(sout);
+  
+  NET_SIZE_T sinlen6 = sizeof(sin6);     
+  NET_SIZE_T soutlen6 = sizeof(sout6);   
 #endif
 
   res = 0;  /* to prevent compiler warning */
@@ -276,6 +280,29 @@
 	      }
 	      posportupdate(target, current, trynum, scan, ss, CONNECT_SCAN, PORT_CLOSED, pil, csi);
 	    } else {
+	      if(o.af == AF_INET6){        /*IPv6*/
+		if (getpeername(sd, (struct sockaddr *) &sin6, &sinlen6) < 0) {
+		  pfatal("error in getpeername of connect_results for port %hu", current->portno);
+		} 
+		else {
+		  if (current->portno != ntohs(sin6.sin6_port)) {
+		    error("Mismatch!!!! we think we have port %hu but we really have %hu", current->portno, ntohs(sin6.sin6_port));
+		  }
+		}
+		if (getsockname(sd, (struct sockaddr *) &sout6, &soutlen6) < 0) {
+		  pfatal("error in getsockname for port %hu", current->portno);
+		}
+		if (htons(sout6.sin6_port) == current->portno) {
+		  /* Linux 2.2 bug can lead to bogus successful connect()ions
+		     in this case -- we treat the port as bogus even though it
+		     is POSSIBLE that this is a real connection */
+		  posportupdate(target, current, trynum, scan, ss, CONNECT_SCAN, PORT_CLOSED, pil, csi);
+		} 
+		else {
+		  posportupdate(target, current, trynum, scan, ss, CONNECT_SCAN, PORT_OPEN, pil, csi);
+		}
+	      }
+	      else{     /*IPv4*/
 	      if (getpeername(sd, (struct sockaddr *) &sin, &sinlen) < 0) {
 		pfatal("error in getpeername of connect_results for port %hu", current->portno);
 	      } else {
@@ -296,6 +323,7 @@
 		posportupdate(target, current, trynum, scan, ss, CONNECT_SCAN, PORT_OPEN, pil, csi);
 	      }
 	    }
+	    }
 	  } else {
 	    posportupdate(target, current, trynum, scan, ss, CONNECT_SCAN, PORT_OPEN, pil, csi);
 	  }
@@ -342,6 +370,7 @@
 		     stype scantype) {
 
   struct ip *ip;
+  struct ip6_hdr *ip6;
   unsigned int bytes;
   struct tcphdr *tcp;
   int trynum;
@@ -350,7 +379,9 @@
   int newport;
   struct portinfo *current = NULL;
   struct icmp *icmp;
+  struct icmp6_hdr *icmp6;
   struct ip *ip2;
+  struct ip6_hdr *ip6_2;
   u16 *data;
   struct timeval tv;
   struct timeval start;
@@ -358,6 +389,186 @@
 
   gettimeofday(&start, NULL);
 
+  if(o.af == AF_INET6){              /* IPv6 */
+    while (!quit && ss->numqueries_outstanding > 0 && 
+	   ( ip6 = (struct ip6_hdr*) readip_pcap(pd, &bytes, target->to.timeout))) {
+      //if (bytes < (4 * ip->ip_hl) + 4U)      ??? hey what is this?
+      //	continue;       
+      current = NULL;
+      trynum = newport = -1;
+      newstate = PORT_UNKNOWN;
+      
+      gettimeofday(&tv, NULL);
+      
+      /* Insure there is no timeout ... */
+      if (o.host_timeout) {	
+	if (TIMEVAL_MSEC_SUBTRACT(tv, target->host_timeout) >= 0) {
+	  target->timedout = 1;
+	  return;
+	}
+      }
+      
+      /* If this takes at least 1.5 secs and is more than the targets
+	 timeout, lets get out of here.  Otherwise stray network packets
+	 could cause us trouble. */
+      if ( TIMEVAL_SUBTRACT(tv, start) > MAX(target->to.timeout, 1500)) {
+	/* Lets quit after we process this packet */
+	quit = 1;
+      }
+      
+      if (ip6->ip6_src.s6_addr32[0] == target->host6.s6_addr32[0] &&
+	  ip6->ip6_src.s6_addr32[1] == target->host6.s6_addr32[1] &&
+	  ip6->ip6_src.s6_addr32[2] == target->host6.s6_addr32[2] &&
+	  ip6->ip6_src.s6_addr32[3] == target->host6.s6_addr32[3] &&
+	  ip6->ip6_nxt == IPPROTO_TCP) {
+	tcp = (struct tcphdr *) (((char *) ip6) + sizeof(struct ip6_hdr)); 
+	i = ntohs(tcp->th_dport);
+	if (i < o.magic_port || i > o.magic_port + 15) {
+	  if (o.debugging > 1)
+	    error("SYN scan got TCP packet to port %d (magic port is %d) ... ignoring", i, o.magic_port);
+	  continue;
+	}
+	newport = ntohs(tcp->th_sport);
+	/* In case we are scanning localhost and see outgoing packets */
+	/* If only one of SYN, ACK flags are set, we skip it */
+	if (ip6->ip6_src.s6_addr32[0] == target->source_ipv6.s6_addr32[0] &&
+	    ip6->ip6_src.s6_addr32[1] == target->source_ipv6.s6_addr32[1] &&
+	    ip6->ip6_src.s6_addr32[2] == target->source_ipv6.s6_addr32[2] &&
+	    ip6->ip6_src.s6_addr32[3] == target->source_ipv6.s6_addr32[3] &&
+	    ((tcp->th_flags == TH_ACK) || (tcp->th_flags == TH_SYN))) {
+	  continue;
+	}
+	if (portlookup[newport] < 0) {
+	  if (o.debugging) {
+	    log_write(LOG_STDOUT, "Strange packet from port %d:\n", ntohs(tcp->th_sport));
+	    readtcppacket6((unsigned char *)ip6, bytes);
+	  }
+	  current = NULL;
+	  continue;
+	}	      
+	
+	current = &scan[portlookup[newport]];
+	for(i=0; i < 3; i++) {
+	  if (MOD_DIFF(sequences[i],ntohl(tcp->th_ack)) < 5)
+	    break;
+	}
+	if (i < 3) trynum = i;
+	else {
+	  if (o.debugging) 
+	    log_write(LOG_STDOUT, "Strange ACK number from target: %lX\n", (unsigned long) ntohl(tcp->th_ack));
+	  trynum = (current->trynum == 0)? 0 : -1;	    
+	}
+	if (current->trynum < trynum) {
+	  if (o.debugging) 	    
+	    error("Received SYN packet implying trynum %d from port %hu even though that port is only on trynum %d (could be from an earlier round)", trynum, newport, current->trynum);
+	  trynum = -1;
+	}
+	if (scantype == SYN_SCAN) {
+	  if (tcp->th_flags & TH_RST) {
+	    newstate = PORT_CLOSED;
+	  } else if ((tcp->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {
+	    newstate = PORT_OPEN;
+	  } else {
+	    if (o.debugging)
+	      error("Received response to SYN scan with unexpected tcp flags: %d\n", tcp->th_flags);
+	    continue;
+	  }
+	}
+	else if (scantype == WINDOW_SCAN) {
+	  if (tcp->th_flags & TH_RST) {
+	    if (tcp->th_win) {
+	      newstate = PORT_OPEN;
+	    } else {
+	      newstate = PORT_CLOSED;
+	    }
+	  } else {
+	    if (o.debugging)
+	      error("Received response to WINDOW scan with unexpected tcp flags: %d\n", tcp->th_flags);
+	    continue;
+	  }
+	}
+	else if (scantype == ACK_SCAN) {
+	  if (tcp->th_flags & TH_RST) {	  
+	    newstate = PORT_UNFIREWALLED;
+	  } else {
+	    if (o.debugging)
+	      error("Received response to ACK scan with unexpected tcp flags: %d\n", tcp->th_flags);
+	    continue;
+	  }
+	} else {
+	  fatal("Unknown scan type!#$!@#$ passed to get_syn_results!  Please notify fyodor@insecure.org");
+	}
+      }
+
+    
+      else if (ip6->ip6_nxt == IPPROTO_ICMPV6) {
+	icmp6 = (struct icmp6_hdr *) ((char *)ip6 + sizeof(struct ip6_hdr));
+	ip6_2 = (struct ip6_hdr *) (((char *) ip6) + sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr));
+	//if (bytes <= 4 * ip->ip_hl + 28U ||
+	//    bytes <= /* IP1len */ 4 * ip->ip_hl + /*ICMPlen */ 8 +    ?????????
+	//    /* IP2len */ 4 * ip2->ip_hl + 4U /* TCP ports */) 
+	/*  {
+	    if (o.debugging) {                                      
+	      error("Icmp message too short (%d bytes)", bytes);
+	    }
+	    continue;
+	  }
+	*/
+	
+	/* Lets ensure this packet relates to a packet to the host
+	   we are scanning ... */
+	if(ip6_2->ip6_dst.s6_addr32[0] != target->host6.s6_addr32[0] ||
+	   ip6_2->ip6_dst.s6_addr32[1] != target->host6.s6_addr32[1] ||
+	   ip6_2->ip6_dst.s6_addr32[2] != target->host6.s6_addr32[2] ||
+	   ip6_2->ip6_dst.s6_addr32[3] != target->host6.s6_addr32[3]){
+	  if (o.debugging > 1)
+	    error("Got an ICMP message which does not relate to a packet sent to the host being scanned");
+	  continue;
+	}
+
+	data = (u16 *) ((char *)ip6_2 + sizeof(struct ip6_hdr));
+	
+	/*	    log_write(LOG_STDOUT, "Caught ICMP packet:\n");
+		    hdump(icmp, ntohs(ip->ip_len) - sizeof(struct ip)); */
+	if (icmp6->icmp6_type == 1) {
+	  if (icmp6->icmp6_code != 0 && icmp->icmp_code != 1 && 
+	      icmp6->icmp6_code != 2 && 
+	      icmp6->icmp6_code != 3 && icmp->icmp_code != 4) {
+	    error("Unexpected ICMPv6 type/code 1/%d unreachable packet:", icmp6->icmp6_code);
+	    hdump((unsigned char *)icmp6, ntohs(ip6->ip6_plen));
+	    continue;
+	  }
+	  
+	  newport = ntohs(data[1]);
+	  if (portlookup[newport] >= 0) {
+	    current = &scan[portlookup[newport]];
+	    trynum = (current->trynum == 0)? 0 : -1;
+	    newstate = PORT_FIREWALLED;
+	  } else { 
+	    if (o.debugging) {
+	      error("Illegal ICMP type/code 1/%d unreachable packet:", 
+		    icmp6->icmp6_code);
+	      hdump((unsigned char *)icmp6, ntohs(ip6->ip6_plen));
+	    }
+	    continue;
+	  }	      
+	}
+      }      
+   
+      /* OK, now we manipulate the port lists and adjust the time */
+      if (current) {
+	posportupdate(target, current, trynum, scan, ss, SYN_SCAN, newstate,
+		      pil, NULL);
+	current = NULL;
+	trynum = -1;
+	newstate = PORT_UNKNOWN;
+      }
+    }
+    return;
+  }
+
+
+  else{    /* IPv4  */  
   while (!quit && ss->numqueries_outstanding > 0 && 
 	 ( ip = (struct ip*) readip_pcap(pd, &bytes, target->to.timeout))) {
     if (bytes < (4 * ip->ip_hl) + 4U)
@@ -518,6 +729,7 @@
   }
   return;
 }
+}
 
 /* Handles the "positive-response" scans (where we get a response
    telling us that the port is open based on the probe.  This includes
@@ -540,6 +752,7 @@
   int starttime;
   struct hostent *myhostent = NULL;
   struct sockaddr_in sock;
+  struct sockaddr_in6 sock6; 
   struct portinfo *scan = NULL,  *current, *next;
   struct portinfolist pil;
   int portlookup[65536]; /* Indexes port number -> scan[] index */
@@ -549,9 +762,12 @@
   u32 sequences[3]; /* for various reasons we use 3 separate
 				 ones rather than simply incrementing from
 				 a base */
-  int i;
+  int i, k;
   unsigned long j;
 
+  char buf[INET6_ADDRSTRLEN];           
+  struct addrinfo hints, *result;       
+
   if (target->timedout)
     return;
 
@@ -628,7 +844,7 @@
   /* Init our raw socket */
   if ((scantype == SYN_SCAN) || (scantype == WINDOW_SCAN) || 
       (scantype == ACK_SCAN)) {  
-    if ((rawsd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0 )
+    if ((rawsd = socket(o.af, SOCK_RAW, IPPROTO_RAW)) < 0 )
       pfatal("socket troubles in pos_scan");
     /* We do not wan't to unblock the socket since we want to wait 
        if kernel send buffers fill up rather than get ENOBUF, and
@@ -642,8 +858,23 @@
     get_random_bytes(sequences, sizeof(sequences));
 
     /* Do we have a correct source address? */
+    if(o.af == AF_INET6){
+      if (!target->source_ipv6.s6_addr) {
+	hints.ai_family = AF_INET6;    
+	if (gethostname(myname, MAXHOSTNAMELEN) != 0 && 
+	    (getaddrinfo(myname, NULL, &hints, &result)))
+	  fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n"); 
+	memcpy(&target->source_ipv6, result->ai_addr, sizeof(struct in6_addr));
+	if (o.debugging || o.verbose) 
+	  log_write(LOG_STDOUT, "We skillfully deduced that your address is %s\n",
+		    inet_ntop(AF_INET6, &(target->source_ipv6), buf, sizeof(buf)));
+	
+      }
+    }
+    else{
+      /* Do we have a correct source address? */
     if (!target->source_ip.s_addr) {
-      if (gethostname(myname, MAXHOSTNAMELEN) != 0 ||
+	if (gethostname(myname, MAXHOSTNAMELEN) != 0 && 
 	  !((myhostent = gethostbyname(myname))))
 	fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n"); 
       memcpy(&target->source_ip, myhostent->h_addr_list[0], sizeof(struct in_addr));
@@ -651,14 +882,22 @@
 	log_write(LOG_STDOUT, "We skillfully deduced that your address is %s\n",
 		inet_ntoa(target->source_ip));
     }
+    }
     
     /* Now for the pcap opening nonsense ...
        Note that the snaplen is 100 = 64 byte max IPhdr + 24 byte max 
        link_layer header + first 12 bytes of TCP header.
     */
     
+    if(o.af == AF_INET6)
+      pd = my_pcap_open_live(target->device, 110,  (o.spoofsource)? 1 : 0, 20);
+    else
     pd = my_pcap_open_live(target->device, 100,  (o.spoofsource)? 1 : 0, 20);
     
+    /* ipv6 note: I didn't bother with the filter since it should be an 
+     *            ipv4 type of mask... but it works...
+     */
+ 
     flt_srchost = target->host.s_addr;
     flt_dsthost = target->source_ip.s_addr;
 
@@ -676,9 +915,19 @@
   } else if (scantype == CONNECT_SCAN) {
     rawsd = -1;
     /* Init our sock */
+    if(o.af == AF_INET6){   /*IPv6*/
+      bzero((char *)&sock6,sizeof(struct sockaddr_in6));  
+      sock6.sin6_family=AF_INET6;
+      for(k=0;k<4;k++)
+	sock6.sin6_addr.s6_addr32[k]= target->host6.s6_addr32[k];
+      sock6.sin6_flowinfo=0;         
+      sock6.sin6_scope_id=if_nametoindex(target->device);  
+    }
+    else{ /* IPv4 */
     bzero((char *)&sock,sizeof(struct sockaddr_in));
     sock.sin_addr.s_addr = target->host.s_addr;
     sock.sin_family=AF_INET;
+    }
   } else if (scantype == RPC_SCAN) {
     get_rpc_procs(&(rsi.rpc_progs), &(rsi.rpc_number));
     scan = (struct portinfo *) safe_malloc(rsi.rpc_number * sizeof(struct portinfo));
@@ -816,9 +1065,9 @@
 		now = current->sent[current->trynum];
 		if ((scantype == SYN_SCAN) || (scantype == WINDOW_SCAN) || (scantype == ACK_SCAN)) {	      
 		  if (o.fragscan)
-		    send_small_fragz_decoys(rawsd, &target->host, sequences[current->trynum], o.magic_port + tries * 3 + current->trynum, current->portno, scanflags);
+		    send_small_fragz_decoys(rawsd, target, sequences[current->trynum], o.magic_port + tries * 3 + current->trynum, current->portno, scanflags);
 		  else 
-		    send_tcp_raw_decoys(rawsd, &target->host, o.magic_port + 
+		    send_tcp_raw_decoys(rawsd, target, o.magic_port + 
 					tries * 3 + current->trynum, 
 					current->portno, 
 					sequences[current->trynum], 
@@ -857,14 +1106,21 @@
 		  } else {
 		    ss.numqueries_outstanding++;
 		  }
-		  res = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+		  res = socket(o.af, SOCK_STREAM, IPPROTO_TCP);
 		  if (res == -1) pfatal("Socket troubles in pos_scan 143");
 		  csi.socklookup[res] = current;
 		  unblock_socket(res);
 		  init_socket(res);
+		  if(o.af == AF_INET6){   /*IPv6*/         
+		      sock6.sin6_port = htons(current->portno);
+		      current->sd[current->trynum] = res;
+		      res =  connect(res,(struct sockaddr *)&sock6,sizeof(struct sockaddr_in6));
+		  }
+		  else{   /* IPv4 */
 		  sock.sin_port = htons(current->portno);
 		  current->sd[current->trynum] = res;		
-		  res =  connect(res,(struct sockaddr *)&sock,sizeof(struct sockaddr));
+		      res =  connect(res,(struct sockaddr *)&sock,sizeof(struct sockaddr_in));
+		  }	
 		  if (res != -1) {
 		    posportupdate(target, current, current->trynum, scan, &ss, scantype, PORT_OPEN, &pil, &csi);
 		  } else {
@@ -912,9 +1168,9 @@
 	    if ((scantype == SYN_SCAN) || (scantype == WINDOW_SCAN) || 
 		(scantype == ACK_SCAN)) {	  
 	      if (o.fragscan)
-		send_small_fragz_decoys(rawsd, &target->host, sequences[current->trynum], o.magic_port + tries * 3, current->portno, scanflags);
+		send_small_fragz_decoys(rawsd, target, sequences[current->trynum], o.magic_port + tries * 3, current->portno, scanflags);
 	      else
-		send_tcp_raw_decoys(rawsd, &target->host, 
+		send_tcp_raw_decoys(rawsd, target, 
 				    o.magic_port + tries * 3, current->portno,
 				    sequences[current->trynum], ack_number, 
 				    scanflags, 0, NULL, 0, o.extra_payload, 
@@ -928,7 +1184,7 @@
 		break;
 	      }
 	    } else { /* CONNECT SCAN */
-	      res = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+	      res = socket(o.af, SOCK_STREAM, IPPROTO_TCP);
 	      if (res == -1) pfatal("Socket troubles in pos_scan 11234");
 #ifdef WIN32
 	      if(res > 2047)
@@ -937,9 +1193,18 @@
 	      csi.socklookup[res] = current;
 	      unblock_socket(res);
 	      init_socket(res);
+
+	      if(o.af == AF_INET6){         /*IPv6*/   
+		sock6.sin6_port = htons(current->portno);
+		current->sd[current->trynum] = res;	 
+		res =  connect(res,(struct sockaddr *)&sock6,sizeof(struct sockaddr_in6));	
+	      }
+	      else{  /*IPv4*/
 	      sock.sin_port = htons(current->portno);
 	      current->sd[current->trynum] = res;		
-	      res =  connect(res,(struct sockaddr *)&sock,sizeof(struct sockaddr));
+		res =  connect(res,(struct sockaddr *)&sock,sizeof(struct sockaddr_in));  /*sizeof: was sockaddr??*/  
+	      }
+
 	      if (res != -1) {
 		posportupdate(target, current, current->trynum, scan, &ss, scantype, PORT_OPEN, &pil, &csi);
 	      } else {
@@ -1226,6 +1491,7 @@
   pcap_t *pd;
   unsigned int bytes;
   struct ip *ip, *ip2;
+  struct ip6_hdr *ip6, *ip6_2;
   struct tcphdr *tcp;
   char filter[512];
   char *p;
@@ -1249,8 +1515,11 @@
   int packet_trynum = 0;
   int windowdecrease = 0; /* Has the window been decreased this round yet? */
   struct icmp *icmp;
+  struct icmp6_hdr *icmp6;
   int portno;
   struct port *current_port_tmp;
+  char addr_buf[INET6_ADDRSTRLEN];                      
+  struct addrinfo hints, *result;   
 
   if (target->timedout)
     return;
@@ -1290,7 +1559,7 @@
 
     
   /* Init our raw socket */
-  if ((rawsd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0 )
+  if ((rawsd = socket(o.af, SOCK_RAW, IPPROTO_RAW)) < 0 )
     pfatal("socket troubles in super_scan");
   broadcast_socket(rawsd); /* This isn't pretty, but I don't have much of a
 			      choice */
@@ -1301,8 +1570,23 @@
   */
 
   /* Do we have a correct source address? */
+  if(o.af == AF_INET6){     /* IPv6 */
+    if (!target->source_ipv6.s6_addr) {
+      hints.ai_family = AF_INET6;    
+      if (gethostname(myname, MAXHOSTNAMELEN) != 0 && 
+	  (getaddrinfo(myname, NULL, &hints, &result)))
+	fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n"); 
+      memcpy(&target->source_ipv6, result->ai_addr, sizeof(struct in6_addr));
+      if (o.debugging || o.verbose) 
+	log_write(LOG_STDOUT, "We skillfully deduced that your address is %s\n",
+		  inet_ntop(AF_INET6, &(target->source_ipv6), addr_buf, sizeof(addr_buf)));
+    }
+  } 
+    
+  else{  /* IPv4 */
+    /* Do we have a correct source address? */
   if (!target->source_ip.s_addr) {
-    if (gethostname(myname, MAXHOSTNAMELEN) != 0 ||
+      if (gethostname(myname, MAXHOSTNAMELEN) != 0 && 
 	!((myhostent = gethostbyname(myname))))
       fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n"); 
     memcpy(&target->source_ip, myhostent->h_addr_list[0], sizeof(struct in_addr));
@@ -1310,6 +1594,7 @@
       log_write(LOG_STDOUT, "We skillfully deduced that your address is %s\n",
 	      inet_ntoa(target->source_ip));
   }
+  }
 
   /* Now for the pcap opening nonsense ... */
   /* Note that the snaplen is 92 = 64 byte max IPhdr + 24 byte max link_layer
@@ -1319,6 +1604,21 @@
   pd = my_pcap_open_live(target->device, 92,  (o.spoofsource)? 1 : 0, 10);
 
 
+  if(o.af == AF_INET6){    /* IPv6 */
+    pd = my_pcap_open_live(target->device, 110,  (o.spoofsource)? 1 : 0, 10); 
+    /* 92 wasn't enough for icmpv6 packets */
+
+    flt_srchost = target->host6.s6_addr;
+    flt_dsthost = target->source_ipv6.s6_addr;
+    flt_baseport = o.magic_port;
+
+    p = strdup(inet_ntop(AF_INET6, &(target->host6), addr_buf, sizeof(addr_buf)));
+    snprintf(filter, sizeof(filter), "(icmp and dst host %s) or (tcp and src host %s and dst host %s and ( dst port %d or dst port %d))", inet_ntop(AF_INET6, &(target->source_ipv6), addr_buf, sizeof(addr_buf)), p,  inet_ntop(AF_INET6, &(target->source_ipv6), addr_buf, sizeof(addr_buf)),o.magic_port , o.magic_port + 1);
+    free(p);
+  }
+  else{  /* IPv4 */
+    pd = my_pcap_open_live(target->device, 92,  (o.spoofsource)? 1 : 0, 10); 
+
   flt_srchost = target->host.s_addr;
   flt_dsthost = target->source_ip.s_addr;
   flt_baseport = o.magic_port;
@@ -1326,6 +1626,7 @@
   p = strdup(inet_ntoa(target->host));
   snprintf(filter, sizeof(filter), "(icmp and dst host %s) or (tcp and src host %s and dst host %s and ( dst port %d or dst port %d))", inet_ntoa(target->source_ip), p, inet_ntoa(target->source_ip), o.magic_port , o.magic_port + 1);
   free(p);
+  }
 
   set_pcap_filter(target, pd, flt_icmptcp_2port, filter);
 
@@ -1339,8 +1640,12 @@
 
   starttime = time(NULL);
 
-  if (o.debugging || o.verbose)
-    log_write(LOG_STDOUT, "Initiating %s against %s (%s)\n", scantype2str(scantype), target->name, inet_ntoa(target->host));
+  if (o.debugging || o.verbose){
+    if(o.af == AF_INET6)                                       /* SEB IPv6  */
+      log_write(LOG_STDOUT, "Initiating %s against %s (%s)\n", scantype2str(scantype), target->name, inet_ntop(o.af,&(target->host6), addr_buf, sizeof(addr_buf)));
+    else 
+      log_write(LOG_STDOUT, "Initiating %s against %s (%s)\n", scantype2str(scantype), target->name, inet_ntop(o.af,&(target->host), addr_buf, sizeof(addr_buf)));
+  }
   
 
   do {
@@ -1394,14 +1699,14 @@
 		gettimeofday(&current->sent[1], NULL);
 		now = current->sent[1];
 		if (o.fragscan)
-		  send_small_fragz_decoys(rawsd, &target->host, 0,i, current->portno, scanflags);
+		  send_small_fragz_decoys(rawsd, target, 0,i, current->portno, scanflags);
 		else if (scantype == UDP_SCAN)
-		  send_udp_raw_decoys(rawsd, &target->host, i,
+		  send_udp_raw_decoys(rawsd, target, i,
 				      current->portno, o.extra_payload, o.extra_payload_length);
 		else if (scantype == IPPROT_SCAN)
 		  send_ip_raw_decoys(rawsd, &target->host, current->portno, o.extra_payload, o.extra_payload_length);
 		else
-		  send_tcp_raw_decoys(rawsd, &target->host, i, 
+		  send_tcp_raw_decoys(rawsd, target, i, 
 				      current->portno, 0, 0, scanflags, 0, NULL, 0,
 				      o.extra_payload, o.extra_payload_length);
 		if (senddelay &&
@@ -1423,15 +1728,15 @@
 	    numqueries_outstanding++;
 	    gettimeofday(&current->sent[0], NULL);
 	    if (o.fragscan)
-	      send_small_fragz_decoys(rawsd, &target->host, 0, o.magic_port, current->portno, scanflags);
+	      send_small_fragz_decoys(rawsd, target, 0, o.magic_port, current->portno, scanflags);
 	    else if (scantype == UDP_SCAN)
-	      send_udp_raw_decoys(rawsd, &target->host, o.magic_port,
+	      send_udp_raw_decoys(rawsd, target, o.magic_port,
 				  current->portno, o.extra_payload, o.extra_payload_length);
 	    else if (scantype == IPPROT_SCAN)
 	      send_ip_raw_decoys(rawsd, &target->host,
 				 current->portno, o.extra_payload, o.extra_payload_length);
 	    else
-	      send_tcp_raw_decoys(rawsd, &target->host, o.magic_port, 
+	      send_tcp_raw_decoys(rawsd, target, o.magic_port, 
 				  current->portno, 0, 0, scanflags, 0, NULL, 0,
 				  o.extra_payload, o.extra_payload_length);
 	    if ((scantype == UDP_SCAN || scantype == IPPROT_SCAN) &&
@@ -1451,6 +1756,198 @@
 	    target->timedout = 1;
 	    goto superscan_timedout;
 	  }
+
+	if(o.af == AF_INET6){      /* IPv6 */     
+	  while (!timedout && numqueries_outstanding > 0 && ( ip6 = (struct ip6_hdr*) readip_pcap(pd, &bytes, target->to.timeout)))
+	    {
+	      if (++packcount >= 30) {
+		/* We don't want to allow for the possibility if this going
+		   forever */
+		gettimeofday(&end, NULL);
+		if (TIMEVAL_SUBTRACT(end, now) > 8000000)
+		  timedout = 1;
+	      }
+	      //if (bytes < (4 * ip->ip_hl) + 4U)  ??????
+	      //continue;                         ??????	
+
+	      current = NULL;
+	     	      
+	      if (ip6->ip6_nxt == IPPROTO_ICMPV6 ||
+		  (ip6->ip6_src.s6_addr32[0] == target->host6.s6_addr32[0] &&
+		   ip6->ip6_src.s6_addr32[1] == target->host6.s6_addr32[1] &&
+		   ip6->ip6_src.s6_addr32[2] == target->host6.s6_addr32[2] &&
+		   ip6->ip6_src.s6_addr32[3] == target->host6.s6_addr32[3])) {
+		if (ip6->ip6_nxt == IPPROTO_TCP) {
+		  tcp = (struct tcphdr *) (((char *) ip6) + sizeof(struct ip6_hdr));
+		  if (tcp->th_flags & TH_RST) {	    
+		    newstate = PORT_CLOSED;
+		    newport = ntohs(tcp->th_sport);
+		    if (portlookup[newport] < 0) {
+		      if (o.debugging) {
+			log_write(LOG_STDOUT, "Strange packet from port %d:\n", ntohs(tcp->th_sport));
+			readtcppacket6((unsigned char *)ip6, bytes);
+		      }
+		      current = NULL;
+		      continue;
+		    }	  
+		    current = &scan[portlookup[newport]];
+		  
+		    if (ntohs(tcp->th_dport) != o.magic_port && 
+			ntohs(tcp->th_dport) != o.magic_port + 1) {
+		      if (o.debugging)  {		
+			error("BAD TCP packet detected to port %d from port %d", ntohs(tcp->th_dport), newport);
+		      }
+		      continue;		
+		    }
+		    
+		    if (current->state != PORT_TESTING && o.debugging) {
+		      error("TCP packet detected from port %d which is in state %d (should usually be PORT_TESTING (but not always)", 
+			    newport, current->state); 
+		    }
+		    
+		    if (!o.magic_port_set) {
+		      packet_trynum = ntohs(tcp->th_dport) - o.magic_port;
+		      if ((packet_trynum|1) != 1) packet_trynum = -1;
+		    }  else packet_trynum = -1;
+		    if (current->trynum == 0) packet_trynum = 0;
+		  } else { continue; } /* Wrong TCP flags */
+		  
+		} else if (ip6->ip6_nxt == IPPROTO_ICMPV6) {
+		  icmp6 = (struct icmp6_hdr *) ((char *)ip6 + sizeof(struct ip6_hdr));
+		  ip6_2 = (struct ip6_hdr *) ((char *)ip6 + sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr));
+		  if (ip6_2->ip6_dst.s6_addr32[0] != target->host6.s6_addr32[0] ||
+		      ip6_2->ip6_dst.s6_addr32[1] != target->host6.s6_addr32[1] ||
+		      ip6_2->ip6_dst.s6_addr32[2] != target->host6.s6_addr32[2] ||
+		      ip6_2->ip6_dst.s6_addr32[3] != target->host6.s6_addr32[3])
+		      continue;
+		  data = (u16 *) ((char *)ip6_2 + sizeof(struct ip6_hdr));
+		
+		  if (icmp6->icmp6_type == 4 &&
+		      icmp6->icmp6_code == 1){    /* pr0t0c0l unreachable */
+		    //if (scantype == IPPROT_SCAN) 
+		      //newstate = PORT_CLOSED;
+		     
+		  }
+
+		  if (icmp6->icmp6_type == 1) {
+		    if (scantype != IPPROT_SCAN)
+		      newport = ntohs(data[1]);
+		    else
+		      newport = ip6_2->ip6_nxt;
+		    if (portlookup[newport] < 0) {
+		      if (o.debugging) {
+			log_write(LOG_STDOUT, "Strange ICMP packet type 3 code %d related to port %d:\n", icmp6->icmp6_code, newport);
+			readtcppacket((unsigned char *)ip6, bytes);		
+		      }
+		      continue;		
+		    }
+		    current = &scan[portlookup[newport]];
+		    if (!o.magic_port_set) {
+		      packet_trynum = ntohs(data[0]) - o.magic_port;
+		      if ((packet_trynum|1) != 1) packet_trynum = -1;
+		    } else {
+		      if (current->trynum == 0)  {
+			packet_trynum = 0;
+		      }
+		      else packet_trynum = -1;
+		    }
+		    
+		   
+		    switch(icmp6->icmp6_code) {
+		       
+		    case 1: /* Administratively prohibited packet */
+		      newstate = PORT_FIREWALLED;
+		      break;		
+		   
+		    case 4: /* p0rt unreachable */		
+		      if (scantype == UDP_SCAN) {
+			newstate = PORT_CLOSED;
+		      } else newstate = PORT_FIREWALLED;
+		      break; 
+  
+		    default:
+		      if (o.debugging) {
+			error("Received strange ICMP destunreach response -- code: %d", icmp6->icmp6_code);
+			hdump((unsigned char *)icmp6, ntohs(sizeof(struct ip6_hdr)) - 
+			      sizeof(struct ip6_hdr));
+		      }
+		      continue;
+		    }
+		  }
+		} else if (ip6->ip6_nxt == IPPROTO_UDP) {
+		  if (UDPPacketWarning == 0) {
+		    UDPPacketWarning = 1;
+		    if (o.debugging)
+		      error("UDP packet received\n");
+		  }
+		  continue;
+		} else if (scantype == IPPROT_SCAN) {
+		  if (o.debugging)
+		    error("packet with protocol %d received\n", ip6->ip6_nxt);
+		}
+		
+		if (current) {	  
+		  if (current->state == PORT_CLOSED && (packet_trynum < 0)) {
+		    target->to.rttvar = (int) (target->to.rttvar * 1.2);
+		    if (o.debugging) { log_write(LOG_STDOUT, "Late packet, couldn't figure out sendno so we do varianceincrease to %d\n", target->to.rttvar); 
+		    }
+		  } 
+		  if (packet_trynum > -1) {		
+		    /* Update our records */
+		    adjust_timeouts(current->sent[packet_trynum], &(target->to));
+		    numqueries_ideal = MIN(numqueries_ideal + (packet_incr/numqueries_ideal), max_width);
+		    if (packet_trynum > 0 && current->trynum > 0) {
+		      /* The first packet was apparently lost, slow down */
+		      dropped++;
+		      if (freshportstried > 50 && ((double) dropped/freshportstried) > 0.3) {
+			if (!senddelay) senddelay = 50000;
+			else senddelay = MIN(senddelay * 2, 1000000);
+			if (senddelay >= 200000 &&
+			    (scantype == UDP_SCAN || scantype == IPPROT_SCAN))
+			  max_width = MIN(max_width,2);
+			freshportstried = 0;
+			dropped = 0;
+			if (o.verbose || o.debugging )  
+			  log_write(LOG_STDOUT, "Too many drops ... increasing senddelay to %d\n", senddelay);
+		      }
+		      if (windowdecrease == 0) {
+			numqueries_ideal *= fallback_percent;
+			if (numqueries_ideal < 1) numqueries_ideal = 1;
+			if (o.debugging) { log_write(LOG_STDOUT, "Lost a packet, decreasing window to %d\n", (int) numqueries_ideal);
+			windowdecrease++;
+			if (scantype == UDP_SCAN || scantype == IPPROT_SCAN)
+			  usleep(250000);
+			}
+		      } else if (o.debugging > 1) { 
+			log_write(LOG_STDOUT, "Lost a packet, but not decreasing\n");
+		      }
+		    }
+		  }    
+		  if (current->state != newstate) {
+		    changed++;
+		  }
+		  if (current->state != PORT_OPEN && 
+		      current->state != PORT_CLOSED) {	    
+		    numqueries_outstanding--;
+		  }
+		  if (current->state == PORT_TESTING && current == testinglist)
+		    testinglist = (current->next >= 0)?  &scan[current->next] : NULL;
+		  else if (current->state == PORT_OPEN && current == openlist)
+		    openlist = (current->next >= 0)? &scan[current->next] : NULL;
+		  if (current->next >= 0) scan[current->next].prev = current->prev;
+		  if (current->prev >= 0) scan[current->prev].next = current->next;
+		  current->next = current->prev = -1;
+		  current->state = newstate;
+		  addport(&target->ports, current->portno, 
+			  (scantype == UDP_SCAN)? IPPROTO_UDP :
+			  (scantype == IPPROT_SCAN? IPPROTO_IP: IPPROTO_TCP), 
+			  NULL, current->state);
+		}
+	      }
+	    }
+	}
+
+	else{      /* IPv4  */
 	while (!timedout && numqueries_outstanding > 0 && ( ip = (struct ip*) readip_pcap(pd, &bytes, target->to.timeout)))
 	  {
 	    if (++packcount >= 30) {
@@ -1635,6 +2132,7 @@
 	    }
 	  }
       } 
+      } 
   
     
     /* Prepare for retry */
diff -u -r -w nmap-2.54BETA36/targets.c nmap-2.54BETA36_ipv6/targets.c
--- nmap-2.54BETA36/targets.c	Sun Apr 21 02:20:09 2002
+++ nmap-2.54BETA36_ipv6/targets.c	Tue Jun 18 18:10:39 2002
@@ -257,6 +257,43 @@
   return 1;
 }
 
+int target_struct_get6(struct targets6 *t, struct in6_addr *sin6) {
+  int i;
+  char addr_buf[INET6_ADDRSTRLEN];
+
+  startover: /* to hande nmap --resume where I have already
+		scanned many of the IPs */  
+
+  if((t->nleft) <= 0)
+      return -1;    
+       
+  if (t->maskformat) {
+    if (smaller_or_equal_v6(t->currentaddr, t->end))
+    {
+      for(i=0;i<4;i++)
+	sin6->s6_addr32[i] = t->currentaddr.s6_addr32[i];  
+      
+      t->currentaddr.s6_addr32[3]=htonl(ntohl(t->currentaddr.s6_addr32[3]) + 1);
+    }
+    else { 
+      error("Bogus target structure passed to target_struct_get");
+      t->nleft = 0;
+      for(i=0;i<4;i++)
+	sin6->s6_addr32[i] = 0;
+      return -1;
+    }
+  }
+/* !!! the next part is for a different type of mask. must still be done. */ 
+  else {
+    for(i=0;i<4;i++)
+      sin6->s6_addr32[i] = t->currentaddr.s6_addr32[i]; 
+  }
+  t->nleft--;
+  assert(t->nleft >= 0);
+  return 1;
+}
+
+
 /* Undoes the previous target_struct_get operation */
 void target_struct_return(struct targets *t) {
   int octet;
@@ -292,6 +329,7 @@
 int hidx;
 char *device;
 int i;
+char buf [INET6_ADDRSTRLEN];                                 
 
 if (hs->next_batch_no < hs->current_batch_sz) {
   /* Woop!  This is easy -- we just pass back the next host struct */
@@ -301,6 +339,50 @@
 bzero(hs->hostbatch, hs->max_batch_sz * sizeof(struct hoststruct));
 hs->current_batch_sz = hs->next_batch_no = 0;
 do {
+  if(o.af == AF_INET6){           /*IPv6*/
+    /* Grab anything we have in our current_expression */
+    while(hs->current_batch_sz < hs->max_batch_sz && 
+	  target_struct_get6(&hs->current_expression6, 
+			     &(hs->hostbatch[hs->current_batch_sz].host6)) != -1)
+      {
+	hidx = hs->current_batch_sz;
+	
+	/* Lets figure out what device this IP uses ... */
+	if (o.source) {
+	  memcpy((char *)&hs->hostbatch[hidx].source_ipv6,(char *) o.source6, 
+		 sizeof(struct in6_addr));
+	  strcpy(hs->hostbatch[hidx].device, o.device);
+	} else {
+	  /* In all cases we search for the route.
+	   * Seems that we need the device even for the connect call
+	   * (for Linux)
+	   */
+	  device = routethrough6(&(hs->hostbatch[hidx].host6), &(hs->hostbatch[hidx].source_ipv6));	
+	  if (!device) {
+	    if (*pingtype == PINGTYPE_NONE) {
+	      fatal("Could not determine what interface to route packets through, run again with -e <device>");
+	    } else {
+	      error("WARNING:  Could not determine what interface to route packets through to %s, changing ping scantype to ICMP only", inet_ntop(AF_INET6, &(hs->hostbatch[hidx].host6), buf, sizeof(buf)));
+	      *pingtype = PINGTYPE_ICMP_PING;
+	    }
+	  } else {
+	    strcpy(hs->hostbatch[hidx].device, device);
+	  }
+	  
+	}
+	
+	/* In some cases, we can only allow hosts that use the same device in a group. */
+	if (o.isr00t && hidx > 0 && *hs->hostbatch[hidx].device && hs->hostbatch[hidx].source_ip.s_addr != hs->hostbatch[0].source_ip.s_addr) {
+	  /* Cancel everything!  This guy must go in the next group and we are outtof here */
+	  target_struct_return(&(hs->current_expression));
+	  goto batchfull;
+	}
+	
+	hs->current_batch_sz++;
+      } 
+  }
+
+  else{
   /* Grab anything we have in our current_expression */
   while (hs->current_batch_sz < hs->max_batch_sz && 
 	 target_struct_get(&hs->current_expression, 
@@ -349,14 +431,23 @@
 
       hs->current_batch_sz++;
     }
+  }
 
   if (hs->current_batch_sz < hs->max_batch_sz &&
       hs->next_expression < hs->num_expressions) {
     /* We are going to have to plop in another expression. */
+    if(o.af == AF_INET6){                                      /*IPv6*/
+      while (!parse_targets6(&(hs->current_expression6), hs->target_expressions[hs->next_expression++])) { 	      
+	if (hs->next_expression >= hs->num_expressions)
+	  break;
+      }
+    }
+    else{                        /*IPv4*/
     while (!parse_targets(&(hs->current_expression), hs->target_expressions[hs->next_expression++])) {
       if (hs->next_expression >= hs->num_expressions)
 	break;
     }     
+    }     
   } else break;
 } while(1);
  batchfull:
@@ -534,6 +625,94 @@
 }
 
 
+
+int parse_targets6(struct targets6 *targets6, char *h){
+  int i=0/*,j=0,k=0*/;
+  //long start, end, temp;
+  char *r,*s, *target_net;
+  char *addy[5];
+  char *hostexp = strdup(h);
+  unsigned long longtmp;
+  int namedhost = 1;
+  unsigned int adr_tmp_end[4], adr_tmp_start[4];
+  struct addrinfo hints, *result;
+  char addr_buf[INET6_ADDRSTRLEN];
+  
+  bzero(targets6, sizeof(struct targets6));
+  addy[0] = addy[1] = addy[2] = addy[3] = addy[4] = NULL;
+  addy[0] = r = hostexp;
+  
+  target_net = strtok(hostexp, "/");
+  s = strtok(NULL, "");    /* find the end of the token from hostexp */
+  targets6->netmask  = ( s ) ? atoi(s) : 128;
+  if ((int) targets6->netmask < 96 || targets6->netmask > 128) {
+    fprintf(stderr, "Illegal netmask value (  %d), must be from /96 to /128 . If your mask is under /96, I should probably ask you if you're really intending to scan more than 4294967296 hosts...??\nAssuming /128 (one host).\n ", targets6->netmask);
+    targets6->netmask = 128;
+  }  
+  /* Here we have to test if the address is named. */
+  for(i=0; *(hostexp + i); i++) 
+    if ( *(hostexp +i) == ':') {
+      namedhost = 0;
+      break;
+    } 
+  if (targets6->netmask != 128 || namedhost) {
+    targets6->maskformat = 1;
+    hints.ai_family = AF_INET6;  
+    if ((inet_pton(AF_INET6, target_net, &(targets6->start)) <= 0))
+      {
+	if((!getaddrinfo(target_net, NULL, &hints, &result)))	
+	  {  
+	    memcpy(&(targets6->start),  &((struct sockaddr_in6 *)result->ai_addr)->sin6_addr, sizeof(struct in6_addr));
+	    printf("\nIPv6 address found for host %s --> %s\n", target_net, inet_ntop(AF_INET6, &(targets6->start), addr_buf, sizeof(addr_buf))); 
+	  }
+	else {
+	  fprintf(stderr, "Failed to resolve given hostname/IPv6: %s\n", target_net);
+	  free(hostexp);
+	  return 0;
+	}
+      }
+    
+    memcpy(&(targets6->end), &(targets6->start), sizeof(struct in6_addr));
+
+    longtmp = ntohl(targets6->start.s6_addr32[3]);
+    targets6->start.s6_addr32[3] = htonl(longtmp & (unsigned long) (0 - (1<<(128 - targets6->netmask))));
+    targets6->end.s6_addr32[3] = htonl(longtmp | (unsigned long)  ((1<<(128 - targets6->netmask)) - 1));
+    
+    targets6->currentaddr = targets6->start;
+
+    for(i=0; i<=3; i++){
+      adr_tmp_end[i] = ntohl(targets6->end.s6_addr32[i]); 
+      adr_tmp_start[i] = ntohl(targets6->start.s6_addr32[i]);
+    }
+    
+    if (targets6->start.s6_addr32[3] <= targets6->end.s6_addr32[3]) { 
+      targets6->nleft = adr_tmp_end[3] - adr_tmp_start[3] + 1;
+      free(hostexp); 
+      return 1;  
+    }    
+    fprintf(stderr, "Host specification invalid");
+    free(hostexp);
+    return 0;
+  }
+
+  
+  /* Next part doesn't work...to be done.  */
+  else {
+    i=0;
+    targets6->maskformat = 0;
+    
+    /* debug for one host ipv6 */
+    inet_pton(AF_INET6, target_net, &(targets6->currentaddr));
+  }
+
+  targets6->nleft = 1;   // debug one host
+
+  free(hostexp);
+  return 1;
+}
+
+
+
 void massping(struct hoststruct *hostbatch, int num_hosts, 
               struct scan_lists *ports, int pingtype) {
 static struct timeout_info to = { 0,0,0};
@@ -854,10 +1033,10 @@
  myseq = (get_random_uint() << 19) + (seq << 3) + 3; /* Response better end in 011 or 100 */
  memcpy((char *)&(o.decoys[o.decoyturn]), (char *)&target->source_ip, sizeof(struct in_addr));
  if (pingtype & PINGTYPE_TCP_USE_SYN) {   
-   send_tcp_raw_decoys( rawsd, &(target->host), sportbase + trynum, o.tcp_probe_port, myseq, myack, TH_SYN, 0, NULL, 0, o.extra_payload, 
+   send_tcp_raw_decoys( rawsd, target, sportbase + trynum, o.tcp_probe_port, myseq, myack, TH_SYN, 0, NULL, 0, o.extra_payload, 
 			o.extra_payload_length);
  } else {
-   send_tcp_raw_decoys( rawsd, &(target->host), sportbase + trynum, o.tcp_probe_port, myseq, myack, TH_ACK, 0, NULL, 0, o.extra_payload, 
+   send_tcp_raw_decoys( rawsd, target, sportbase + trynum, o.tcp_probe_port, myseq, myack, TH_ACK, 0, NULL, 0, o.extra_payload, 
 			o.extra_payload_length);
  }
 
diff -u -r -w nmap-2.54BETA36/targets.h nmap-2.54BETA36_ipv6/targets.h
--- nmap-2.54BETA36/targets.h	Tue Jun  4 19:29:41 2002
+++ nmap-2.54BETA36_ipv6/targets.h	Sat Jun 15 15:13:57 2002
@@ -141,6 +141,7 @@
    in sin and then zero is returned and state information in t is updated
    to reflect that the IP was pulled out.  If t is empty, -1 is returned */
 int target_struct_get(struct targets *t, struct in_addr *sin);
+int target_struct_get6(struct targets6 *t, struct in6_addr *sin6);
 /* Undoes the previous target_struct_get operation */
 void target_struct_return(struct targets *t);
 void hoststructfry(struct hoststruct *hostbatch, int nelem);
@@ -152,6 +153,7 @@
    free the actual memory allocated to the hoststruct itself (for all
    this function knows, you could have declared it on the stack */
 void hoststruct_free(struct hoststruct *currenths);
+int parse_targets6(struct targets6 *targets6, char *h);
 #endif /* TARGETS_H */
 
 
diff -u -r -w nmap-2.54BETA36/tcpip.c nmap-2.54BETA36_ipv6/tcpip.c
--- nmap-2.54BETA36/tcpip.c	Sun Apr 21 02:20:09 2002
+++ nmap-2.54BETA36_ipv6/tcpip.c	Tue Jun 18 19:38:25 2002
@@ -102,6 +102,28 @@
 }
 
 
+int islocalhost6(struct in6_addr *addr) {
+char dev[128];
+  /* If it is  ::1 then it is probably localhost */
+
+  if (addr->s6_addr32[0] == htonl(0) &&
+      addr->s6_addr32[1] == htonl(0) &&
+      addr->s6_addr32[2] == htonl(0) &&
+      addr->s6_addr32[3] == htonl(1))
+    return 1;
+
+  /* If it is the same addy as a local interface, then it is
+     probably localhost */
+
+  if (ipaddr2devname6(dev, addr) != -1)
+    return 1;
+
+  /* OK, so to a first approximation, this addy is probably not
+     localhost */
+  return 0;
+}
+
+
 /* Calls pcap_open_live and spits out an error (and quits) if the call faile.
    So a valid pcap_t will always be returned. */
 pcap_t *my_pcap_open_live(char *device, int snaplen, int promisc, int to_ms) 
@@ -174,17 +196,24 @@
   return 0;
 }
 
-int send_tcp_raw_decoys( int sd, struct in_addr *victim, u16 sport, 
+int send_tcp_raw_decoys( int sd, struct hoststruct *victim, u16 sport, 
 			 u16 dport, u32 seq, u32 ack, u8 flags, u16 window, 
                          u8 *options, int optlen, u8 *data, u16 datalen) 
 {
   int decoy;
 
+  if(o.af == AF_INET6){    /* IPv6 */
   for(decoy = 0; decoy < o.numdecoys; decoy++) 
-    if (send_tcp_raw(sd, &o.decoys[decoy], victim, sport, dport, seq, ack,
+      if (send_tcp_raw6(sd, &o.decoys6[decoy], victim, sport, dport, seq, ack,
 		     flags, window, options, optlen, data, datalen) == -1)
       return -1;
-
+  }
+  else{                    /* IPv4 */
+    for(decoy = 0; decoy < o.numdecoys; decoy++) 
+      if (send_tcp_raw(sd, &o.decoys[decoy], &(victim->host), sport, dport, seq, ack,
+		       flags, window, options, optlen, data, datalen) == -1)
+	return -1;
+  }
   return 0;
 }
 
@@ -329,23 +358,175 @@
 return res;
 }
 
+
+
+int send_tcp_raw6( int sd, struct in6_addr *source, struct hoststruct *victim, 
+		   u16 sport, u16 dport, u32 seq, u32 ack, u8 flags,
+		   u16 window, u8 *options, int optlen, char *data, 
+		   u16 datalen)  
+{	   
+  struct pseudo_header6 {  /* for computing the checksum. */
+    struct in6_addr s_addy;
+    struct in6_addr d_addr;
+    u32 up_layer_lenght;
+    u16 zer0;
+    u8 zer02;
+    u8 next_header;
+  };
+
+  /* We build here a IPv6 packet with no Extension Header. */
+
+  u8 *packet = (u8 *) safe_malloc(sizeof(struct ip6_hdr) + sizeof(struct tcphdr) + optlen + datalen);  /* Total lenght of the packet. */
+  struct ip6_hdr *ip6 = (struct ip6_hdr *) packet;
+  struct tcphdr *tcp = (struct tcphdr *) (packet + sizeof(struct ip6_hdr));
+  struct pseudo_header6 *pseudo = (struct pseudo_header6 *) (packet + sizeof(struct ip6_hdr) - sizeof(struct pseudo_header6)); 
+  static int hop_lim = 0;
+
+  /* With these placement we get data and some field alignment so we aren't
+   * wasting too much in computing the checksum.
+   */
+
+  int k, res = -1;
+  struct sockaddr_in6 sock6;
+  char myname[MAXHOSTNAMELEN + 1];
+  struct addrinfo hints, *result;
+  int source_malloced = 0;
+   
+  /* check that required fields are there and not too silly 
+   * We used to check that sport and dport were nonzer0, but scr3w that!
+   */
+
+  if ( !victim || sd < 0) {
+    fprintf(stderr, "send_tcp_raw: One or more of your parameters suck!\n");
+    free(packet);
+    return -1;
+  }
+  
+  if (optlen % 4) {
+    fatal("send_tcp_raw called with an option length argument of %d which is illegal because it is not divisible by 4", optlen);
+  }
+
+  if (!hop_lim) hop_lim = (get_random_uint() % 23) + 37;
+  
+ 
+  sethdrinclude(sd); 
+  
+  /* if they didn't give a source address, fill in our first address */
+
+  if (!source) {
+    source_malloced = 1;
+    source = (struct in6_addr *) safe_malloc(sizeof(struct in6_addr));
+
+    hints.ai_family = AF_INET6;
+    if (gethostname(myname, MAXHOSTNAMELEN) || 
+	(getaddrinfo(myname, NULL, &hints, &result)))    
+      fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n");
+    
+    memcpy(source, &((struct sockaddr_in6 *)result->ai_addr)->sin6_addr, sizeof(struct in6_addr));
+  }  
+  
+
+  sock6.sin6_family = AF_INET6;
+  sock6.sin6_port = htons(0); /* Must leave 0(< +- 500), or doesn't sendto ????!!!! */
+  for(k=0;k<4;k++)
+    sock6.sin6_addr.s6_addr32[k]= victim->host6.s6_addr32[k];
+  sock6.sin6_flowinfo=0;   
+  sock6.sin6_scope_id=if_nametoindex(victim->device); 
+
+  bzero((char *) packet, sizeof(struct ip6_hdr) + sizeof(struct tcphdr));
+
+  for(k=0;k<4;k++)
+    {
+      pseudo->s_addy.s6_addr32[k] = source->s6_addr32[k];
+      pseudo->d_addr.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+  pseudo->next_header = IPPROTO_TCP;
+  pseudo->up_layer_lenght = htonl(sizeof(struct tcphdr) + datalen);
+
+  tcp->th_sport = htons(sport);
+  tcp->th_dport = htons(dport);
+  if (seq) {
+    tcp->th_seq = htonl(seq);
+  }
+  else if (flags & TH_SYN) {
+    get_random_bytes(&(tcp->th_seq), 4);
+  }
+
+  if (ack)
+    tcp->th_ack = htonl(ack); 
+
+  tcp->th_off = 5 + (optlen /4) /*data offset*/;
+  tcp->th_flags = flags;
+
+  if (window)
+    tcp->th_win = htons(window);
+  else tcp->th_win = htons(1024 * (hop_lim % 4 + 1)); /* Who cares */
+  
+  /* We should probably copy the data over too */
+  if (data && datalen)
+    memcpy(packet + sizeof(struct ip6_hdr) + sizeof(struct tcphdr) + optlen, data, datalen);
+ 
+#if STUPID_SOLARIS_CHECKSUM_BUG
+  tcp->th_sum = sizeof(struct tcphdr) + datalen; 
+#else
+  tcp->th_sum = in_cksum((unsigned short *)pseudo, sizeof(struct tcphdr) + 
+			 optlen + sizeof(struct pseudo_header6) + datalen);
+#endif
+
+
+  /* Now for the ip6 header */
+  
+  bzero(packet, sizeof(struct ip6_hdr));
+  ip6->ip6_flow = htonl(0x60000000); 
+  ip6->ip6_plen = htons(sizeof(struct tcphdr) + datalen); 
+  ip6->ip6_nxt = IPPROTO_TCP;
+  ip6->ip6_hlim =  hop_lim;
+  for(k=0;k<4;k++)
+    {
+      ip6->ip6_src.s6_addr32[k] = source->s6_addr32[k];
+      ip6->ip6_dst.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+
+  if(TCPIP_DEBUGGING > 1)
+    {
+      log_write(LOG_STDOUT, "Raw TCP packet creation completed!  Here it is:\n");
+      readtcppacket6(packet, 1);
+    }
+  
+ 
+  res = Sendto("send_tcp_raw6", sd, packet, ntohs(ip6->ip6_plen) + sizeof(struct ip6_hdr), 0,(struct sockaddr *)&sock6,  sizeof(struct sockaddr_in6));
+  
+  if (source_malloced) free(source);
+  free(packet);
+  return res; 
+}
+
+
+
 int Sendto(char *functionname, int sd, const unsigned char *packet, int len, 
 	   unsigned int flags, struct sockaddr *to, int tolen) {
 
 struct sockaddr_in *sin = (struct sockaddr_in *) to;
+struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) to;
 int res;
 int retries = 0;
 int sleeptime = 0;
+char addr_buf[INET6_ADDRSTRLEN], *host;    
+
+if(o.af == AF_INET6)                                        
+  host = &(sin6->sin6_addr);             
+else
+  host = &(sin->sin_addr);     
 
 do {
   if (TCPIP_DEBUGGING > 1) {  
     log_write(LOG_STDOUT, "trying sendto(%d, packet, %d, 0, %s, %d)",
-	   sd, len, inet_ntoa(sin->sin_addr), tolen);
+	   sd, len, inet_ntop(o.af, host, addr_buf, sizeof(addr_buf)), tolen);
   }
   if ((res = sendto(sd, (const char *) packet, len, flags, to, tolen)) == -1) {
     error("sendto in %s: sendto(%d, packet, %d, 0, %s, %d) => %s",
-	  functionname, sd, len, inet_ntoa(sin->sin_addr), tolen,
-	  strerror(errno));
+	  functionname, sd, len, inet_ntop(o.af, host, addr_buf, 
+          sizeof(addr_buf)), tolen,  strerror(errno));
     if (retries > 2 || errno == EPERM) 
       return -1;
     sleeptime = 15 * (1 << (2 * retries));
@@ -419,6 +600,66 @@
 return 0;
 }
 
+
+int readtcppacket6(unsigned char *packet, int readdata) 
+{ 
+  struct ip6_hdr *ip6 = (struct ip6_hdr *) packet;
+  struct tcphdr *tcp = (struct tcphdr *) (packet + sizeof(struct ip6_hdr));
+  int payload_len;
+  struct in6_addr bullshit, bullshit2;
+  
+  char sourcehost[46], desthost[46];
+  int k;
+  
+  printf("\nRaw TCP packet creation completed!  Here it is:\n");
+
+  if (!packet) {
+    fprintf(stderr, "readtcppacket: packet is NULL!\n");
+    return -1;
+  }
+  
+  for(k=0;k<4;k++){
+    bullshit.s6_addr32[k] = ip6->ip6_src.s6_addr32[k]; 
+    bullshit2.s6_addr32[k] = ip6->ip6_dst.s6_addr32[k];
+  }
+  
+ 
+  payload_len = (ip6->ip6_plen);
+  inet_ntop(AF_INET6, &bullshit, sourcehost, sizeof(sourcehost));
+  inet_ntop(AF_INET6, &bullshit2, desthost, sizeof(desthost));
+
+ 
+
+  if (ip6->ip6_nxt == IPPROTO_TCP) {
+    printf("Version&Class&Flow label: %ux\n", ip6->ip6_flow);
+    printf("Payload lenght: %i\n", ntohs(ip6->ip6_plen));
+    printf("Next Header: %i\n", ip6->ip6_nxt);
+    printf("Hop limit: %i\n", ip6->ip6_hlim);
+    printf("TCP-IPv6 packet: %s[%d] -> %s[%d] \n", sourcehost, 
+    	   ntohs(tcp->th_sport), desthost, 
+    	   ntohs(tcp->th_dport));
+    
+    printf("Flags: ");
+    if (!tcp->th_flags) printf("(none)");
+    if (tcp->th_flags & TH_RST) printf("RST ");
+    if (tcp->th_flags & TH_SYN) printf("SYN ");
+    if (tcp->th_flags & TH_ACK) printf("ACK ");
+    if (tcp->th_flags & TH_PUSH) printf("PSH ");
+    if (tcp->th_flags & TH_FIN) printf("FIN ");
+    if (tcp->th_flags & TH_URG) printf("URG ");
+    printf("\n");
+         
+    if (tcp->th_flags & (TH_SYN | TH_ACK))
+      printf("Seq: %u\tAck: %u\n",   (unsigned int) ntohl(tcp->th_seq), (unsigned int) ntohl(tcp->th_ack));
+    else if (tcp->th_flags & TH_SYN) printf("Seq: %u\n", (unsigned int) ntohl(tcp->th_seq));
+    else if (tcp->th_flags & TH_ACK) printf("Ack: %u\n", (unsigned int) ntohl(tcp->th_ack));  
+  }
+ 
+  return 0;
+}
+
+
+
 /* A simple function I wrote to help in debugging, shows the important fields
    of a UDP packet*/
 int readudppacket(unsigned char *packet, int readdata) {
@@ -462,14 +703,22 @@
  return 0;
 }
 
-int send_udp_raw_decoys( int sd, struct in_addr *victim, u16 sport, 
+int send_udp_raw_decoys( int sd, struct hoststruct *victim, u16 sport, 
 			 u16 dport, u8 *data, u16 datalen) {
   int decoy;
   
+  if(o.af == AF_INET6){    /* IPv6 */                                      
+    for(decoy = 0; decoy < o.numdecoys; decoy++) 
+      if (send_udp_raw6(sd, &o.decoys6[decoy], victim, sport, dport, data, 
+		       datalen) == -1)
+	return -1;
+  }
+  else{                    /* IPv4 */
   for(decoy = 0; decoy < o.numdecoys; decoy++) 
-    if (send_udp_raw(sd, &o.decoys[decoy], victim, sport, dport, data, 
+      if (send_udp_raw(sd, &o.decoys[decoy], &(victim->host), sport, dport, data, 
 		     datalen) == -1)
       return -1;
+  }
 
   return 0;
 }
@@ -587,15 +836,186 @@
 return res;
 }
 
-int send_small_fragz_decoys(int sd, struct in_addr *victim, u32 seq, 
+
+int send_udp_raw6( int sd, struct in6_addr *source, struct hoststruct *victim, 
+		  u16 sport, u16 dport, u8 *data, u16 datalen) 
+{	   
+  struct pseudo_header6 {  /* for computing the checksum. */
+    struct in6_addr s_addy;
+    struct in6_addr d_addr;
+    u32 up_layer_lenght;
+    u16 zer0;
+    u8 zer02;
+    u8 next_header;
+  };
+  unsigned char *packet = (unsigned char *) safe_malloc(sizeof(struct ip6_hdr) + sizeof(struct udphdr_bsd) + datalen);
+  struct ip6_hdr *ip6 = (struct ip6_hdr *) packet;
+  struct udphdr_bsd *udp = (struct udphdr_bsd *) (packet + sizeof(struct ip6_hdr));
+  struct pseudo_header6 *pseudo = (struct pseudo_header6 *) (packet + sizeof(struct ip6_hdr) - sizeof(struct pseudo_header6)); 
+  static int hop_lim = 0;
+  
+  int res,k;
+  struct sockaddr_in6 sock6;
+  char myname[MAXHOSTNAMELEN + 1];
+  struct addrinfo hints, *result;
+  int source_malloced = 0;
+  
+  
+  /* check that required fields are there and not too silly */
+  if ( !victim || !sport || !dport || sd < 0) {
+    fprintf(stderr, "send_udp_raw: One or more of your parameters suck!\n");
+    free(packet);
+    return -1;
+  }
+  
+  
+  if (!hop_lim) hop_lim = (get_random_uint() % 23) + 37;
+  
+  sethdrinclude(sd); 
+  
+  /* if they didn't give a source address, fill in our first address */
+  if (!source) {
+    source_malloced = 1;
+    source = (struct in6_addr *) safe_malloc(sizeof(struct in6_addr));
+    
+    if (gethostname(myname, MAXHOSTNAMELEN) || 
+	(getaddrinfo(myname, NULL, &hints, &result)))    
+      fatal("Cannot get hostname!  Try using -S <my_IP_address> or -e <interface to scan through>\n");
+    
+    memcpy(source, &((struct sockaddr_in6 *)result->ai_addr)->sin6_addr, sizeof(struct in6_addr));
+  }  
+ 
+
+  sock6.sin6_family = AF_INET6;
+  sock6.sin6_port = htons(0); /* Must leave 0(< +- 500), or doesn't sendto ????!!!! */
+  for(k=0;k<4;k++)
+    sock6.sin6_addr.s6_addr32[k]= victim->host6.s6_addr32[k];
+  sock6.sin6_flowinfo=0;   
+  sock6.sin6_scope_id=if_nametoindex(victim->device); 
+
+  bzero((char *) packet, sizeof(struct ip6_hdr) + sizeof(struct udphdr_bsd));
+
+
+  /* Now the pseudo header for checksuming */
+
+  for(k=0;k<4;k++)
+    {
+      pseudo->s_addy.s6_addr32[k] = source->s6_addr32[k];
+      pseudo->d_addr.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+  pseudo->next_header = IPPROTO_UDP;
+  pseudo->up_layer_lenght = htonl(sizeof(struct udphdr_bsd) + datalen);
+
+  udp->uh_sport = htons(sport);
+  udp->uh_dport = htons(dport);
+  udp->uh_ulen = htons(8 + datalen);
+  
+  /* We should probably copy the data over too */
+  if (data)
+    memcpy(packet + sizeof(struct ip6_hdr) + sizeof(struct udphdr_bsd), data, datalen);
+  
+  
+  /* OK, now we should be able to compute a valid checksum */
+#if STUPID_SOLARIS_CHECKSUM_BUG
+  udp->uh_sum = sizeof(struct udphdr) + datalen;
+#else
+  udp->uh_sum = in_cksum((unsigned short *)pseudo, sizeof(struct udphdr_bsd) + 
+			 sizeof(struct pseudo_header6) + datalen );
+#endif
+  
+  /* Goodbye, pseudo header! */
+  bzero(pseudo, 12);
+  
+
+  /* Now for the ip header */
+
+  bzero(packet, sizeof(struct ip6_hdr));
+  ip6->ip6_flow = htonl(0x60000000); 
+  ip6->ip6_plen = htons(sizeof(struct udphdr_bsd) + datalen); 
+  ip6->ip6_nxt = IPPROTO_UDP;
+  ip6->ip6_hlim =  hop_lim;
+  for(k=0;k<4;k++)
+    {
+      ip6->ip6_src.s6_addr32[k] = source->s6_addr32[k];
+      ip6->ip6_dst.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+
+  if(TCPIP_DEBUGGING > 1)
+    {
+      log_write(LOG_STDOUT, "Raw UDP6 packet creation completed!  Here it is:\n");
+      readudppacket6(packet, 1);
+    }
+  
+  res = Sendto("send_udp_raw6", sd, packet, ntohs(ip6->ip6_plen) + sizeof(struct ip6_hdr), 0,
+	       (struct sockaddr *)&sock6,  (int)sizeof(struct sockaddr_in6));
+  
+  if (source_malloced) free(source);
+  free(packet);
+  return res;
+}
+
+int readudppacket6(unsigned char *packet, int readdata) 
+{ 
+  struct ip6_hdr *ip6 = (struct ip6_hdr *) packet;
+  struct udphdr_bsd *udp = (struct udphdr_bsd *) (packet + sizeof(struct ip6_hdr));
+  int payload_len;
+  struct in6_addr bullshit, bullshit2;
+  
+  char sourcehost[46], desthost[46];
+  int k;
+  
+  printf("\nRaw UDP packet creation completed!  Here it is:\n");
+
+  if (!packet) {
+    fprintf(stderr, "readudppacket: packet is NULL!\n");
+    return -1;
+  }
+  
+  for(k=0;k<4;k++){
+    bullshit.s6_addr32[k] = ip6->ip6_src.s6_addr32[k]; 
+    bullshit2.s6_addr32[k] = ip6->ip6_dst.s6_addr32[k];
+  }
+  
+ 
+  payload_len = (ip6->ip6_plen);
+  inet_ntop(AF_INET6, &bullshit, sourcehost, sizeof(sourcehost));
+  inet_ntop(AF_INET6, &bullshit2, desthost, sizeof(desthost));
+
+ 
+
+  if (ip6->ip6_nxt == IPPROTO_UDP) {
+    printf("Version&Class&Flow label: %ux\n", ip6->ip6_flow);
+    printf("Payload lenght: %i\n", ntohs(ip6->ip6_plen));
+    printf("Next Header: %i\n", ip6->ip6_nxt);
+    printf("Hop limit: %i\n", ip6->ip6_hlim);
+    printf("UDP-IPv6 packet: %s[%d] -> %s[%d] \n", sourcehost, 
+    	   ntohs(udp->uh_sport), desthost, 
+    	   ntohs(udp->uh_dport));
+  }
+ 
+ 
+  return 0;
+}
+
+
+int send_small_fragz_decoys(int sd, struct hoststruct *victim, u32 seq, 
 			    u16 sport, u16 dport, int flags) {
   int decoy;
 
+  if(o.af == AF_INET6){   /* IPv6 */            
   for(decoy = 0; decoy < o.numdecoys; decoy++) 
-    if (send_small_fragz(sd, &o.decoys[decoy], victim, seq, sport, 
+      if (send_small_fragz6(sd, &o.decoys6[decoy], victim, seq, sport, 
 				dport, 
 				flags) == -1)
       return -1;
+  }
+  else{                  /* IPv4 */
+    for(decoy = 0; decoy < o.numdecoys; decoy++) 
+      if (send_small_fragz(sd, &o.decoys[decoy], &(victim->host), seq, sport, 
+			   dport, 
+			   flags) == -1)
+	return -1;
+  }
 
   return 0;
 }
@@ -732,6 +1152,133 @@
 return 1;
 }
 
+int send_small_fragz6(int sd, struct in6_addr *source, struct hoststruct *victim, u32 seq, u16 sport, u16 dport, int flags)
+{   
+  struct pseudo_header6 {    /* for computing the checksum. */
+    struct in6_addr s_addy;
+    struct in6_addr d_addr;
+    u32 up_layer_lenght;
+    u16 zer0;
+    u8 zer02;
+    u8 next_header;
+  };
+
+  unsigned char packet[sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + sizeof(struct tcphdr) + 100];
+  struct ip6_hdr *ip6 = (struct ip6_hdr *) packet;
+  struct ip6_frag *ip6frag=  (struct ip6_frag *) (packet + sizeof(struct ip6_hdr));
+  struct tcphdr *tcp = (struct tcphdr *) (packet + sizeof(struct ip6_hdr) + sizeof(struct ip6_frag));
+  struct pseudo_header6 *pseudo = (struct pseudo_header6 *) (packet + sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) - sizeof(struct pseudo_header6)); 
+  unsigned char *frag2 = packet + sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + 16;
+  struct ip6_hdr *ip6_2 = (struct ip6_hdr *) (frag2 - sizeof(struct ip6_hdr) - sizeof(struct ip6_frag)); 
+  struct ip6_frag *ip6frag_2=  (struct ip6_frag *) (frag2 - sizeof(struct ip6_frag)); 
+  static int hop_lim = 0;
+  int res,k; 
+  struct sockaddr_in6 sock6;
+  long id;
+
+  if (!hop_lim)   hop_lim = (time(NULL) % 14) + 51;
+  
+  sethdrinclude(sd);
+  
+  sock6.sin6_family = AF_INET6;
+  sock6.sin6_port = htons(0); /* Must leave 0(< +- 500), or doesn't sendto ????!!!! */
+  for(k=0;k<4;k++)
+    sock6.sin6_addr.s6_addr32[k]= victim->host6.s6_addr32[k];
+  sock6.sin6_flowinfo=0;   
+  sock6.sin6_scope_id=if_nametoindex(victim->device); 
+  
+  bzero((char *) packet, sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + sizeof(struct tcphdr));
+
+  for(k=0;k<4;k++)
+    {
+      pseudo->s_addy.s6_addr32[k] = source->s6_addr32[k];
+      pseudo->d_addr.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+  pseudo->next_header = IPPROTO_TCP;
+  pseudo->up_layer_lenght = htonl(sizeof(struct tcphdr));
+
+  tcp->th_sport = htons(sport);
+  tcp->th_dport = htons(dport);
+  tcp->th_seq = (seq)? htonl(seq) : get_random_uint();
+  tcp->th_off = 5 /*words*/;
+  tcp->th_flags = flags;
+  tcp->th_win = htons(2048); /* Who cares */
+  tcp->th_sum = in_cksum((unsigned short *)pseudo, 
+		       sizeof(struct tcphdr) + sizeof(struct pseudo_header6));
+
+
+  /* Now for the ip header of frag1
+   * ------------------------------
+   */
+
+  bzero(packet, sizeof(struct ip6_hdr) + sizeof(struct ip6_frag));
+  ip6->ip6_flow = htonl(0x60000000); 
+  ip6->ip6_plen = htons(sizeof(struct ip6_frag) + 16); 
+  ip6->ip6_nxt = IPPROTO_FRAGMENT;
+  ip6->ip6_hlim =  hop_lim;
+  for(k=0;k<4;k++)
+    {
+      ip6->ip6_src.s6_addr32[k] = source->s6_addr32[k];
+      ip6->ip6_dst.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+
+
+ /* Now for the fragmentation extension header of frag1 
+  */
+  
+  ip6frag->ip6f_nxt = IPPROTO_TCP;                          /* next header */
+  ip6frag->ip6f_offlg = htons(1); /* more fragments flag */ /* offset, reserved, and flag */
+  id = ip6frag->ip6f_ident =  get_random_u32();             /* identification */
+
+  if (o.debugging > 1) {
+    printf("Frag 1 written: \n");
+    hdump(ip6,sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + 16 );
+  }
+  
+  if ((res = sendto(sd, (const char *) packet,sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + 16 , 0,  (struct sockaddr *)&sock6, sizeof(struct sockaddr_in6))) == -1)
+    {
+      perror("sendto in send_syn_fragz6");
+      return -1;
+    }
+  
+
+  /* Now for the ip header of the second fragment
+   * --------------------------------------------
+   */
+
+  bzero(ip6_2, sizeof(struct ip6_hdr) + sizeof(struct ip6_frag));
+  ip6_2->ip6_flow = htonl(0x60000000); 
+  ip6_2->ip6_plen = htons(sizeof(struct ip6_frag) + 4); 
+  ip6_2->ip6_nxt = IPPROTO_FRAGMENT;
+  ip6_2->ip6_hlim =  hop_lim;
+  for(k=0;k<4;k++)
+    {
+      ip6_2->ip6_src.s6_addr32[k] = source->s6_addr32[k];
+      ip6_2->ip6_dst.s6_addr32[k] = victim->host6.s6_addr32[k];
+    }
+
+ /* Now for the fragmentation extension header of frag2 
+  */
+
+  ip6frag_2->ip6f_nxt = IPPROTO_TCP;                    /* next header */
+  ip6frag_2->ip6f_offlg = htons(16); /* last fragment, offset 2*/ /* offset,reserved, and flag */
+  ip6frag_2->ip6f_ident = id;                           /* identification */
+
+  if (o.debugging > 1) {
+    printf("Frag 2 written: \n");
+    hdump(ip6_2,sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + 4);
+  }
+  
+  if ((res = sendto(sd, (const char *)ip6_2, sizeof(struct ip6_hdr) + sizeof(struct ip6_frag) + 4 , 0, (struct sockaddr_in6 *)&sock6, (int) sizeof(struct sockaddr_in6))) == -1)
+  {
+    perror("sendto in send_tcp_raw6 frag #2");
+    return -1;
+  }
+  
+return 1;
+}
+
+
 int send_ip_raw_decoys( int sd, struct in_addr *victim, u8 proto,
 			u8 *data, u16 datalen) {
 
@@ -1232,6 +1779,29 @@
 return -1;
 }
 
+
+int ipaddr2devname6( char *dev, struct in6_addr *addr ) {
+  struct interface_info *mydevs;
+  int numdevs;
+  int i;
+    
+  mydevs = getinterfaces6(&numdevs);
+  
+  if (!mydevs) return -1;
+  
+  for(i=0; i < numdevs; i++) {
+    if (addr->s6_addr32[0] == mydevs[i].addr6.s6_addr32[0] &&
+	addr->s6_addr32[1] == mydevs[i].addr6.s6_addr32[1] &&
+	addr->s6_addr32[2] == mydevs[i].addr6.s6_addr32[2] &&
+	addr->s6_addr32[3] == mydevs[i].addr6.s6_addr32[3]) {
+      strcpy(dev, mydevs[i].name);
+      return 0;
+    }
+  }
+  return -1;
+}
+
+
 int devname2ipaddr(char *dev, struct in_addr *addr) {
 struct interface_info *mydevs;
 int numdevs;
@@ -1248,8 +1818,27 @@
 }
 return -1;
 }
+
+
+int devname2ipaddr6(char *dev, struct in6_addr *addr) {
+  struct interface_info *mydevs;
+  int numdevs;
+  int i;
+  mydevs = getinterfaces6(&numdevs);
+  
+  if (!mydevs) return -1;
+  
+  for(i=0; i < numdevs; i++) {
+    if (!strcmp(dev, mydevs[i].name)) {  
+      memcpy(addr, (char *) &mydevs[i].addr6, sizeof(struct in6_addr));
+      return 0;
+    }
+  }
+  return -1;
+}
 #endif /* WIN32 */
 
+
 #ifndef WIN32 /* ifdef'd out for now because 'doze apparently doesn't
 		         support ioctl() */
 struct interface_info *getinterfaces(int *howmany) {
@@ -1337,6 +1926,54 @@
 #endif
 
 
+struct interface_info *getinterfaces6(int *howmany) {
+  static struct interface_info mydevs[128];
+  int numinterfaces = 0;
+  char *p, *endptr;
+  char buf[10240], addr[9];   
+  int i,j;                            
+  
+  FILE *devz;
+  
+  devz = fopen("/proc/net/if_inet6", "r");
+  if(devz){
+    while(fgets(buf,sizeof(buf), devz)) {
+      p = strtok(buf, " ");
+      
+      for(j=0;j<4;j++)
+	{
+	  for(i=0;i<8;i++)
+	    addr[i]=buf[i+j*8];
+	  addr[8]='\0';
+	  p = addr;
+	  endptr = NULL;
+	  mydevs[numinterfaces].addr6.s6_addr32[j] = htonl(strtoul(p, &endptr, 16));
+	}
+      
+      for(i=0;i<4;i++)
+	p = strtok(NULL, " \t\n");
+      p = strtok(NULL, " \t\n");
+      endptr = NULL;
+      
+      strcpy(mydevs[numinterfaces].name, p);
+      
+      numinterfaces++;
+      if (numinterfaces == 127)  {      
+	error("My God!  You seem to have WAY too many interfaces!  Things may not work right\n");
+	break;
+      }
+      
+      mydevs[numinterfaces].name[0] = '\0';
+    }
+  }
+  else
+    fatal("Failed to open file /proc/net/if_inet6.  Unable to determine your interfaces(ipv6)."); 
+  if (howmany) *howmany = numinterfaces;
+  return mydevs;
+}
+
+
+
 /* An awesome function to determine what interface a packet to a given
    destination should be routed through.  It returns NULL if no appropriate
    interface is found, oterwise it returns the device name and fills in the
@@ -1492,6 +2129,170 @@
 }
 #endif /* WIN32 */
 
+
+
+char *routethrough6(struct in6_addr *dest, struct in6_addr *source) {
+  static int initialized = 0;
+  int i,j;
+  static enum { procroutetechnique, connectsockettechnique, guesstechnique } technique = procroutetechnique;
+  char buf[10240], addr[9];
+  struct interface_info *mydevs;
+  static struct myroute {
+    struct interface_info *dev;
+    u32 mask;
+    u32 dest[4];
+  } myroutes[ROUTETHROUGH_MAXROUTES];
+  u32 mask128[4];
+  u32 temp_mask;
+  int numinterfaces = 0;
+  char *p, *endptr;
+  char iface[64];
+  static int numroutes = 0;
+  FILE *routez;
+
+  if (!dest) fatal("ipaddr2devname passed a NULL dest address");
+
+  if (!initialized) {  
+    initialized = 1;
+    mydevs = getinterfaces6(&numinterfaces);
+  
+    /* Now we must go through several techniques to determine info */
+   
+    routez = fopen("/proc/net/ipv6_route", "r");
+    
+    if (routez) {
+
+      /* OK, linux style /proc/net/ipv6_route ... we can handle this ... 
+       * Now that we've got the interfaces, we g0 after the r0ut3Z 
+       */ 
+      
+      while(fgets(buf,sizeof(buf), routez)) {
+	p = strtok(buf, " \t\n");
+	
+	for(j=0;j<4;j++)
+	  {
+	    for(i=0;i<8;i++)
+	      addr[i]=buf[i+j*8];
+	    addr[8]='\0';
+	    p = addr;
+	    endptr = NULL;
+	    myroutes[numroutes].dest[j] = strtoul(p, &endptr, 16);
+	  }
+
+	p = strtok(NULL, " \t\n");
+		
+	endptr = NULL;
+	myroutes[numroutes].mask = strtoul(p, &endptr, 16);
+	if (!endptr || *endptr) {
+	  error("Failed to determine mask from /proc/net/route");
+	  continue;
+	}
+	
+	for(i=0; i < 8; i++) 
+	  p = strtok(NULL, " \t\n");	
+	
+	strncpy(iface, p, sizeof(iface));
+	if ((p = strchr(iface, ':'))) {
+	  *p = '\0'; /* To support IP aliasing */
+	}
+	
+	for(i=0; i < numinterfaces; i++)
+	  if (!strcmp(iface, mydevs[i].name)) {
+	    myroutes[numroutes].dev = &mydevs[i];
+	    break;
+	  }
+	if (i == numinterfaces) 
+	  printf("Failed to find interface %s mentioned in /proc/net/route\n", iface);
+	numroutes++;
+	  if (numroutes == ROUTETHROUGH_MAXROUTES)
+	    fatal("My God!  You seem to have WAY too many routes!\n");
+      }
+      fclose(routez);
+    } else {
+      technique = connectsockettechnique;
+      fatal("procroute technique failed, no other techique...for now.");
+	}
+  } else {  
+    mydevs = getinterfaces6(&numinterfaces);
+  }
+
+
+  /* WHEW, that takes care of initializing, now we have the easy job of 
+   * finding which route matches
+   */
+
+  if (islocalhost6(dest)) {
+    if (source){
+      *source =  in6addr_loopback;
+    }
+
+    /* Now we find the localhost interface name, assuming ::1 is
+     * localhost (it damn well better be!)... 
+     */
+    
+    for(i=0; i < numinterfaces; i++) { 
+      if (mydevs[i].addr6.s6_addr32[0] == htonl(0) &&
+	  mydevs[i].addr6.s6_addr32[1] == htonl(0) &&
+	  mydevs[i].addr6.s6_addr32[2] == htonl(0) &&
+	  mydevs[i].addr6.s6_addr32[3] == htonl(1))
+	{
+	  return mydevs[i].name;
+	}
+    }
+    return NULL;
+  }
+  
+  if (technique == procroutetechnique) {   
+    for(i=0; i < numroutes; i++) { 
+     
+      /* We need to transform the mask from integer form
+       * to the 128 bits form.
+       */
+
+      bzero(mask128, 4 * sizeof(mask128));
+      temp_mask = myroutes[i].mask;
+      j = 0;
+      while(temp_mask > 32)
+	{
+	  temp_mask = temp_mask - 32;
+	  mask128[j] = 0xFFFFFFFF;
+	  j++;
+	}
+
+      mask128[j] = 0xFFFFFFFF;
+      temp_mask =  32 - temp_mask;
+      while(temp_mask > 0)
+	{
+	  mask128[j] =  mask128[j] << 1;
+	  temp_mask--;
+	}
+
+      j++;
+      while(j < 4)
+	{
+	  mask128[j] = 0;
+	  j++;
+	}   
+
+      if ((ntohl(dest->s6_addr32[0]) & mask128[0]) == myroutes[i].dest[0] &&
+	  (ntohl(dest->s6_addr32[1]) & mask128[1]) == myroutes[i].dest[1] &&
+	  (ntohl(dest->s6_addr32[2]) & mask128[2]) == myroutes[i].dest[2] &&
+	  (ntohl(dest->s6_addr32[3]) & mask128[3]) == myroutes[i].dest[3]) {
+	if (source) {
+	  for(j=0;j<4;j++)
+	    source->s6_addr32[j] = myroutes[i].dev->addr6.s6_addr32[j];
+	}
+	printf("\n Found route through interface: %s\n\n",myroutes[i].dev->name);
+	return myroutes[i].dev->name;      
+      }
+    }
+  } 
+  else 
+    fatal("I know sendmail technique ... I know rdist technique ... but I don't know what the hell kindof technique you are attempting!!!");
+  return NULL;
+}
+
+
 /* Maximize the receive buffer of a socket descriptor (up to 500K) */
 void max_rcvbuf(int sd) {
   int optval = 524288 /*2^19*/;
@@ -1681,3 +2482,45 @@
 return 0;
 }
 
+
+/* This returns 1 if the in6_addr first is "smaller" than second. It returns 0 if its equal or greater. */
+
+int smaller_than_v6(struct in6_addr first, struct in6_addr second){
+    if(first.s6_addr32[0] < second.s6_addr32[0])
+	return 1;
+    else if(first.s6_addr32[0] > second.s6_addr32[0])
+	return 0;
+    else if(first.s6_addr32[1] < second.s6_addr32[1])
+	return 1;
+    else if(first.s6_addr32[1] > second.s6_addr32[1])
+	return 0;
+    else if(first.s6_addr32[2] < second.s6_addr32[2])
+	return 1;
+    else if(first.s6_addr32[2] > second.s6_addr32[2])
+	return 0;
+    else if(first.s6_addr32[3] < second.s6_addr32[3])
+	return 1;
+    else return 0;
+}
+
+
+/* This returns 1 if the in6_addr first is "smaller or equal" than second. 
+   It returns 0 if its greater. */
+
+int smaller_or_equal_v6(struct in6_addr first, struct in6_addr second){
+    if(first.s6_addr32[0] < second.s6_addr32[0])
+	return 1;
+    else if(first.s6_addr32[0] > second.s6_addr32[0])
+	return 0;
+    else if(first.s6_addr32[1] < second.s6_addr32[1])
+	return 1;
+    else if(first.s6_addr32[1] > second.s6_addr32[1])
+	return 0;
+    else if(first.s6_addr32[2] < second.s6_addr32[2])
+	return 1;
+    else if(first.s6_addr32[2] > second.s6_addr32[2])
+	return 0;
+    else if(first.s6_addr32[3] <= second.s6_addr32[3])
+	return 1;
+    else return 0;
+}
diff -u -r -w nmap-2.54BETA36/tcpip.h nmap-2.54BETA36_ipv6/tcpip.h
--- nmap-2.54BETA36/tcpip.h	Sun Apr 21 02:20:09 2002
+++ nmap-2.54BETA36_ipv6/tcpip.h	Sat Jun 15 18:55:15 2002
@@ -217,6 +217,7 @@
 struct interface_info {
     char name[64];
     struct in_addr addr;
+  struct in6_addr addr6;                                 /*IPv6*/ 
 };
 
 
@@ -255,6 +256,52 @@
 
 #endif /* HAVE_STRUCT_IP */
 
+
+#ifndef HAVE_STRUCT_IP6                                
+#define HAVE_STRUCT_IP6
+
+/* From Linux glibc. */
+
+struct ip6_hdr
+  {
+    union
+      {
+	struct ip6_hdrctl
+	  {
+	    uint32_t ip6_un1_flow;   /* 4 bits version, 8 bits TC,
+					20 bits flow-ID */
+	    uint16_t ip6_un1_plen;   /* payload length */
+	    uint8_t  ip6_un1_nxt;    /* next header */
+	    uint8_t  ip6_un1_hlim;   /* hop limit */
+	  } ip6_un1;
+	uint8_t ip6_un2_vfc;       /* 4 bits version, top 4 bits tclass */
+      } ip6_ctlun;
+    struct in6_addr ip6_src;      /* source address */
+    struct in6_addr ip6_dst;      /* destination address */
+  };
+
+#define ip6_vfc   ip6_ctlun.ip6_un2_vfc
+#define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
+#define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
+#define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
+#define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
+#define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim
+
+
+
+/* Fragment header */
+struct ip6_frag
+  {
+    uint8_t   ip6f_nxt;       /* next header */
+    uint8_t   ip6f_reserved;  /* reserved field */
+    uint16_t  ip6f_offlg;     /* offset, reserved, and flag */
+    uint32_t  ip6f_ident;     /* identification */
+  };
+
+#endif /* HAVE_STRUCT_IP6 */
+
+
+
 #ifdef LINUX
 typedef struct udphdr_bsd {
          unsigned short uh_sport;           /* source port */
@@ -347,6 +394,26 @@
 };
 #endif /* HAVE_STRUCT_ICMP */
 
+
+#ifndef HAVE_STRUCT_ICMP6
+#define HAVE_STRUCT_ICMP6
+
+/* From Linux /usr/include/netinet/icmp6.h GLIBC */          
+struct icmp6_hdr
+  {
+    uint8_t     icmp6_type;   /* type field */
+    uint8_t     icmp6_code;   /* code field */
+    uint16_t    icmp6_cksum;  /* checksum field */
+    union
+      {
+	uint32_t  icmp6_un_data32[1]; /* type-specific field */
+	uint16_t  icmp6_un_data16[2]; /* type-specific field */
+	uint8_t   icmp6_un_data8[4];  /* type-specific field */
+      } icmp6_dataun;
+  };
+#endif /* HAVE_STRUCT_ICMP6 */
+
+
  /* This ideally should be a port that isn't in use for any protocol on our machine or on the target */
 #define MAGIC_PORT 49724
 #define TVAL2LONG(X)  X.tv_sec * 1e6 + X.tv_usec
@@ -363,14 +430,20 @@
    interface is found, oterwise it returns the device name and fills in the
    source parameter */
 char *routethrough(struct in_addr *dest, struct in_addr *source);
+char *routethrough6(struct in6_addr *dest, struct in6_addr *source);
 unsigned short in_cksum(u16 *ptr,int nbytes);
 int send_tcp_raw( int sd, struct in_addr *source, struct in_addr *victim, 
 		  u16 sport, u16 dport, u32 seq, u32 ack, u8 flags,
 		  u16 window, u8 *options, int optlen, char *data, 
 		  u16 datalen);
+int send_tcp_raw6( int sd, struct in6_addr *source, struct hoststruct *victim, 
+		   u16 sport, u16 dport, u32 seq, u32 ack, u8 flags,
+		   u16 window, u8 *options, int optlen, char *data, 
+		   u16 datalen);
 int send_udp_raw( int sd, struct in_addr *source, struct in_addr *victim, 
 		  u16 sport, u16 dport, u8 *data, u16 datalen);
-
+int send_udp_raw6( int sd, struct in6_addr *source, struct hoststruct *victim, 
+		  u16 sport, u16 dport, u8 *data, u16 datalen);
 int send_ip_raw( int sd, struct in_addr *source, struct in_addr *victim, 
 		 u8 proto, u8 *data, u16 datalen);
 
@@ -378,15 +451,17 @@
    doesn't support fragmentation */
 int send_small_fragz(int sd, struct in_addr *source, struct in_addr *victim,
 		     u32 seq, u16 sport, u16 dport, int flags);
+int send_small_fragz6(int sd, struct in6_addr *source, struct hoststruct *victim, 
+		     u32 seq, u16 sport, u16 dport, int flags);
 /* Decoy versions of the raw packet sending functions ... */
-int send_tcp_raw_decoys( int sd, struct in_addr *victim, u16 sport, 
+int send_tcp_raw_decoys( int sd, struct hoststruct *victim, u16 sport, 
 			 u16 dport, u32 seq, u32 ack, u8 flags, u16 window, 
                          u8 *options, int optlen, u8 *data, u16 datalen);
 
-int send_udp_raw_decoys( int sd, struct in_addr *victim, u16 sport, 
+int send_udp_raw_decoys( int sd, struct hoststruct *victim, u16 sport, 
 			 u16 dport, u8 *data, u16 datalen);
 
-int send_small_fragz_decoys(int sd, struct in_addr *victim, u32 seq, 
+int send_small_fragz_decoys(int sd, struct hoststruct *victim, u32 seq, 
 			    u16 sport, u16 dport, int flags);
 
 int send_ip_raw_decoys( int sd, struct in_addr *victim, u8 proto,
@@ -399,13 +474,18 @@
 /* A simple function I wrote to help in debugging, shows the important fields
    of a TCP packet*/
 int readtcppacket(unsigned char *packet, int readdata);
+int readtcppacket6(unsigned char *packet, int readdata); 
 int readudppacket(unsigned char *packet, int readdata);
+int readudppacket6(unsigned char *packet, int readdata); 
 /* Convert an IP address to the device (IE ppp0 eth0) using that address */
 int ipaddr2devname( char *dev, struct in_addr *addr );
+int ipaddr2devname6( char *dev, struct in6_addr *addr );
 /* And vice versa */
 int devname2ipaddr(char *dev, struct in_addr *addr);
+int devname2ipaddr6(char *dev, struct in6_addr *addr);
 /* Where the above 2 functions get their info */
 struct interface_info *getinterfaces(int *howmany);
+struct interface_info *getinterfaces6(int *howmany);     
 void sethdrinclude(int sd);
 int getsourceip(struct in_addr *src, struct in_addr *dst);
 /* Get the source IP and interface name that a packet
@@ -413,6 +493,7 @@
    assigned and thus should be freed */
 char *getsourceif(struct in_addr *src, struct in_addr *dst);
 int islocalhost(struct in_addr *addr);
+int islocalhost6(struct in6_addr *addr);
 int unblock_socket(int sd);
 int Sendto(char *functionname, int sd, const unsigned char *packet, int len, 
 	   unsigned int flags, struct sockaddr *to, int tolen);
@@ -463,6 +544,9 @@
    implemented in isup() for users who are root.  */
 unsigned long calculate_sleep(struct in_addr target);
 
+int smaller_than_v6(struct in6_addr first, struct in6_addr second);      
+int smaller_or_equal_v6(struct in6_addr first, struct in6_addr second);    
+
 #endif /*TCPIP_H*/
 
 
